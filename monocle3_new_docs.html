---
permalink: /monocle3_docs/
sidemenu: true
description: "Documentation for Monocle 3."
modified: 2019-06-07
tags: [monocle, manual, vignette]
---

    <div class= "container">
    <div class= "row">
    <div class= "col-sm-4">
      <nav id= "toc" data-spy= "affix" data-toggle= "toc"></nav>
    </div>
    <!-- main content area -->
    <div class= "col-sm-8">

<h2>Introduction</h2>

<p>Single-cell transcriptome sequencing (sc-RNA-seq) experiments allow us to
  discover new cell types and help us understand how they arise in development.
  The <strong>Monocle 3</strong> package provides a toolkit for analyzing
  single-cell gene expression experiments.
</p>

<p>Monocle 3 can help you perform three main types of analysis:
<ul>
<li><strong>Clustering, classifying, and counting cells.</strong> Single-cell
  RNA-Seq experiments allow you to discover new (and possibly rare) subtypes of
  cells. Monocle 3 helps you identify them.</li>
<li><strong>Constructing single-cell trajectories.</strong> In development,
  disease, and throughout life, cells transition from one state to another.
  Monocle 3 helps you discover these transitions.</li>
<li><strong>Differential expression analysis.</strong> Characterizing new cell
  types and states begins with comparisons to other, better understood cells.
  Monocle 3 includes a sophisticated, but easy-to-use system for differential
  expression.</li>
</ul>
</p>

<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Under construction</h3>
</div>
<div class= "panel-body">
<p>Monocle 3 is currently in the
  <a href="https://en.wikipedia.org/wiki/Software_release_life_cycle#Beta">beta phase</a>
  of its development. This means there are likely bugs and performance issues
  that will need to be addressed. We are working hard towards a stable release,
  but please be patient while Monocle 3 is under construction.</p>

<p>The documentation on this page is also still under construction. Not all
  features currently implemented have been completely documented.</p>
</div>
</div>

<p>For more information on the algorithms at the core of
  <strong>Monocle</strong>, or to learn more about how to use single-cell
  RNA-Seq to study complex biological processes, explore
  <a href= "{{ site.baseurl }}/papers/">our publications</a>.</p>

<p>Before we look at Monocle 3's functions for each of these common analysis
  tasks, let's see how to install Monocle.
</p>

<h2>Installing Monocle 3</h2>

<h3> Required software </h3>

<p>Monocle 3 runs in the <a href= "http://www.r-project.org/">R statistical
computing environment</a>. You will need R version 3.5 or higher,
<a href="http://bioconductor.org/">Bioconductor</a> version 3.5, and
monocle3 0.1.0 or higher to have access to the latest features.</p>

<p>To install Bioconductor, open R and run:</p>
{% highlight R %}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install()
{% endhighlight %}

<p>Next, install a few Bioconductor dependencies that aren't automatically installed:</p>
{% highlight R %}
BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment'))
{% endhighlight %}

<p>Optional: If you would like to use the resolution parameter in cluster_cells, you
  will also need to install one Python package. This can be done with the following code in R:</p>

  {% highlight R %}
install.packages("reticulate")
reticulate::py_install("louvain")
{% endhighlight %}


<p>Now, install monocle3 through the cole-trapnell-lab GitHub, execute:</p>

{% highlight R %}
devtools::install_github('cole-trapnell-lab/monocle3')
{% endhighlight %}

<h3> Testing the installation </h3>

<p> To ensure that Monocle 3 was installed correctly, start a new R session and
  run: </p>

{% highlight R %}
library(monocle3)
{% endhighlight %}

<h2>Getting Help</h2>

<p>Questions about Monocle 3 should be posted on our <a
href= "https://groups.google.com/d/forum/monocle-3-users">Google Group</a>.
Please do not email technical questions to Monocle contributors
directly.</p>

<!-- <h2>Recommended analysis protocol</h2>

<p>Monocle is a powerful toolkit for analyzing single-cell RNA-seq.  You don't need
to use all of its features for every analysis, and there are more than one way
to do some steps. The workflow is broken up into broad steps. When there's more than
one way to do a certain step, we've labeled the options as follows:

<table class= "table">
<tbody>
<tr>
<td><span class= "label label-danger">Required</span></td>
<td>You need to do this.</td>
</tr>
<tr>
<td><span class= "label label-info">Recommended</span> </td>
<td>Of the ways you could do this, we recommend you try this one first.</td>
</tr>
<tr>
<td><span class= "label label-success">Alternative</span></td>
<td>Of the ways you could do this, this way might work better than the one we usually recommend.</td>
</tr>
</tbody>
</table> -->

<h3>Workflow steps at a glance</h3>

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/monocle3_new_workflow.png" width= 760>
</div>

<p>Below, you can see snippets of code that highlight the main steps of
  Monocle 3. Click on the section headers to jump to the detailed sections
  describing each one. </p>

<h4><a href="{{ site.baseurl }}/monocle3_docs/#the-cell-data-set-class">Store data in a cell_data_set object</a></h4>
The first step in working with Monocle 3 is to load up your data into
Monocle 3's main class, <code><a href = "{{ site.baseurl }}/monocle3_docs/#the-cell-data-set-class">cell_data_set</a></code>:

{% highlight R %}
expression_matrix <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_expression.rds"))
cell_metadata <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_colData.rds"))
gene_annotation <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_rowData.rds"))

cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
{% endhighlight %}

<h4><a href= "{{ site.baseurl }}/monocle3_docs/#clustering-and-classifying-your-cells">Cluster your cells</a></h4>

You can easily cluster your cells to find new types:

{% highlight R %}
## Step 1: Normalize and pre-process the data
cds <- preprocess_cds(cds, num_dim = 100, residual_model_formula_str = "~ batch")

## Step 2: Reduce the dimensions using UMAP
cds <- reduce_dimension(cds)

## Step 3: Cluster the cells
cds <- cluster_cells(cds)
{% endhighlight %}

<h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/monocle3_docs/#constructing-single-cell-trajectories">Order cells in pseudotime along a trajectory</a> </h4>
Now, put your cells in order by how much progress they've made through whatever
process you're studying, such as differentiation, reprogramming, or an immune
response.

{% highlight R %}
## Step 4: Learn a graph
cds <- learn_graph(cds)

## Step 5: Order cells
cds <- order_cells(cds)

plot_cells(cds)
{% endhighlight %}

<h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/monocle3_docs/#differential-expression-analysis">Perform differential expression analysis</a> </h4>
Compare groups of cells in myriad ways to find differentially expressed genes,
controlling for batch effects and treatments as you like:

{% highlight R %}
# With regression:
gene_fits <- fit_models(cds, model_formula_str = "~embryo.time")
fit_coefs <- coefficient_table(gene_fits)
emb_time_terms <- fit_coefs %>% filter(term == "embryo.time")
emb_time_terms <- emb_time_terms %>% mutate(q_value = p.adjust(p_value))
sig_genes <- emb_time_terms %>% filter (q_value < 0.05) %>% pull(gene_short_name)

# With graph autocorrelation:
pr_test_res <- graph_test(cds,  neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(pr_test_res, q_value < 0.05))
{% endhighlight %}

<h2>Getting started with Monocle 3</h2>

Monocle 3 takes as input cell by gene expression matrix. Monocle 3 is designed
for use with absolute transcript counts (e.g. from UMI experiments). Monocle 3
works "out-of-the-box" with the transcript count matrices produced by
<a href= "https://support.10xgenomics.com/single-cell/software/overview/welcome">Cell Ranger</a>,
the software pipeline for analyzing experiments from the 10X Genomics Chromium
instrument. Monocle 3 also works well with data from other RNA-Seq workflows
such as <a href= "https://science.sciencemag.org/content/357/6352/661">sci-RNA-Seq</a>
and instruments like the Biorad ddSEQ.

<h3>The cell_data_set class</h3>

Monocle holds single-cell expression data in objects of the
<code>cell_data_set</code> class. The class is derived from the Bioconductor
<code><a href="http://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html">SingleCellExperiment</a></code> class,
which provides a common interface familiar to those who have analyzed other
single-cell experiments with Bioconductor. The class requires three input files:
<p>
<ul>
<li> <code>expression_matrix</code>, a numeric matrix of expression values,
  where rows are genes, and columns are cells </li>
<li> <code>cell_metadata</code>, a data frame, where rows are cells, and
  columns are cell attributes (such as cell type, culture condition, day
  captured, etc.)</li>
<li> <code>gene_metadata</code>, an data frame, where rows are features (e.g.
  genes), and columns are gene attributes, such as biotype, gc content,
  etc.</li>
</ul>
</p>
<p>
<div class= "panel panel-warning">
<div class= "panel-heading">

<h3 class= "panel-title" data-toc-skip>Required dimensions for input files</h3>

</div>
<div class= "panel-body">
The expression value matrix <strong>must</strong>:
<ul>
<li>have the same number of columns as the <code>cell_metadata</code> has
  rows.</li>
<li>have the same number of rows as the <code>gene_metadata</code> has
  rows.</li>
</ul>
Additionally:
<ul>
<li>row names of the <code>cell_metadata</code> object should match the column
  names of the expression matrix. </li>
<li>row names of the <code>gene_metadata</code> object should match row names
  of the expression matrix.</li>
<li> one of the columns of the <code>gene_metadata</code> should be named
  "gene_short_name", which represents the gene symbol or simple name (generally
  used for plotting) for each gene.</li>
</ul>

</div>
</div>
<h3>Generate a cell_data_set</h3>

<p>You can create a new <code>cell_data_set</code> (CDS) object as follows:</p>

<p>
{% highlight R %}
# Load the data
expression_matrix <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_expression.rds"))
cell_metadata <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_colData.rds"))
gene_annotation <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_rowData.rds"))

# Make the CDS object
cds <- new_cell_data_set(expression_matrix,
                                   cell_metadata = cell_metadata,
                                   gene_metadata = gene_annotation)
{% endhighlight %}
</p>

<h3>Generate a cell_data_set from 10X output</h3>
<p>To input data from 10X Genomics Cell Ranger, you can use the
  <code>load_cellranger_data</code> function:</p>

{% highlight R %}
# Provide the path to the Cell Ranger output.
cds <- load_cellranger_data("~/Downloads/10x_data")
{% endhighlight %}


<h3 data-toc-text= "Working with large data sets">Working with large data sets</h3>

<p> Some single-cell RNA-Seq experiments report measurements from tens of
  thousands of cells or more. As instrumentation improves and costs drop,
  experiments will become ever larger and more complex, with many conditions,
  controls, and replicates. A matrix of expression data with 50,000 cells and a
  measurement for each of the 25,000+ genes in the human genome can take up a
  lot of memory. However, because current protocols typically don't capture all
  or even most of the mRNA molecules in each cell, many of the entries of
  expression matrices are zero. Using <i>sparse matrices</i> can help you work
  with huge datasets on a typical computer. We generally recommend the use of
  sparse matrices for most users, as it speeds up many computations even for
  more modestly sized datasets. </p>

<p> To work with your data in a sparse format, simply provide it to Monocle 3
  as a sparse matrix from the <code>Matrix</code> package: </p>

<p>
{% highlight R %}
cds <- new_cell_data_set(as(umi_matrix, "sparseMatrix"),
      cell_metadata = cell_metadata,
      gene_metadata = gene_metadata)
{% endhighlight %}
</p>

<p>
<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Don't accidentally convert to a dense expression matrix</h3>
</div>
<div class= "panel-body">
The output from a number of RNA-Seq pipelines, including Cell Ranger, is
already in a sparseMatrix format (e.g. MTX). If so, you should just pass it
directly to <code>new_cell_data_set</code> without first converting it to a
dense matrix (via <code>as.matrix()</code>, because that may exceed your
available memeory.
</div>
</div>
</p>

Monocle's sparse matrix support is provided by the <code>Matrix</code> package.
Other sparse matrix packages, such as <code>slam</code> or
<code>SparseM</code> are not supported.

<h2>Clustering and classifying your cells</h2>

<p>Single-cell experiments are often performed on tissues containing many cell
  types. Monocle 3 provides a simple set of functions you can use to group your
  cells according to their gene expression profiles into
  <emph>clusters</emph>. Often cells form clusters that correspond to one cell
  type or a set of highly related cell types. Monocle 3 uses techniques to do
  this that are widely accepted in single-cell RNA-seq analysis and similar to
  the approaches used by <a href="https://satijalab.org/seurat/">Seurat</a>,
  <a href="https://scanpy.readthedocs.io/en/stable/">scanpy</a>, and other
  tools.</p>

In this section, you will learn how to cluster cells using Monocle 3. We will
demonstrate the main functions used for clustering with the
<emph>C. elegans</emph> data from
<a href="https://science.sciencemag.org/content/357/6352/661">Cao & Packer et al.</a>
This study described how to do single-cell RNA-seq with combinatorial indexing
in a protocol called "sci-RNA-seq". Cao & Packer et al. used sci-RNA-seq to
produce the first single-cell RNA-seq analysis of a whole animal, so there are
many cell types represented in the data. You can learn more about the dataset
and see how the authors performed the original analysis at the UW Genome Sciences
<a href="http://atlas.gs.washington.edu/worm-rna/">RNA Atlas of the Worm</a>
site.

You can load the data into Monocle 3 like this:

{% highlight R %}
### FIXME: Put these files on the web so they're accessible to others:
expression_matrix <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_expression.rds"))
cell_metadata <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_colData.rds"))
gene_annotation <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_rowData.rds"))

cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)

{% endhighlight %}

<h3>Pre-process the data</h3>

<p>Now that the data's all loaded up, we need to <emph>pre-process</emph> it.
  This step is where you tell Monocle 3 how you want to normalize the data,
  whether to use <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">Principal Components Analysis</a>
  (the standard for RNA-seq) or <a href="https://en.wikipedia.org/wiki/Latent_semantic_analysis">Latent Semantic Indexing</a>
  (common in ATAC-seq), and how to remove any batch effects. We will just use
  the standard PCA method in this demonstration. When using PCA, you should
  specify the number of principal components you want Monocle to compute. </p>

{% highlight R %}
cds = preprocess_cds(cds, num_dim = 100)
{% endhighlight %}

<p>It's a good idea to check that you're using enough PCs to capture most of
  the variation in gene expression across all the cells in the data set. You
  can look at the fraction of variation explained by each PC using
  <code>plot_pc_variance_explained()</code>:</p>

{% highlight R %}
plot_pc_variance_explained(cds)
{% endhighlight %}

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_pc_variance_explained.png" width= 450>
</div>
<!-- Hannah Marker -->
<p>We can see that using more than 100 PCs would capture only a small amount of additional variation, and each additional PC makes downstream steps in Monocle slower.</p>

<h3>Reduce dimensionality and visualize the cells</h3>

<p>Now we're ready to visualize the cells. To do so, you can use either <a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding">t-SNE</a>, which is very popular in single-cell RNA-seq, or <a href="https://github.com/lmcinnes/umap">UMAP</a>, which is increasingly common. Monocle uses UMAP by default, as we feel that it is both faster and better suited for clustering and trajectory analysis in RNA-seq. To reduce the dimensionality of the data down into the X, Y plane so we can plot it easily, call <code>reduce_dimension()</code>:</p>

{% highlight R %}
cds = reduce_dimension(cds)
{% endhighlight %}

<p>To plot the data, use Monocle's main plotting function, <code>plot_cells()</code>:</p>

{% highlight R %}
plot_cells(cds)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_no_color.png" width= 760>
</div>

<p>Each point in the plot above represents a different cell in the <code>cell_data_set</code> object <code>cds</code></p>. As you can see the cells form many groups, some with thousands of cells, some with only a few. Cao & Packer annotated each cell according to type manually by looking at which genes it expresses. We can color the cells in the UMAP plot by the authors' original annotations using the <code>color_cells_by</code> argument to <code>plot_cells()</code>.

{% highlight R %}
plot_cells(cds, color_cells_by="cao_cell_type")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_color_by_cao_type.png" width= 760>
</div>

<p>You can see that many of the cell types land very close to one another in the UMAP plot.</p>

<p>Except for a few cases described in a moment, <code>color_cells_by</code> can be the name of any column in <code>colData(cds)</code>. Note that when <code>color_cells_by</code> is a categorical variable, labels are added to the plot, with each label positioned roughly in the middle of all the cells that have that label.</p>

<p>You can also color your cells according to how much of a gene or set of genes they express:</p>

{% highlight R %}
plot_cells(cds, genes=c("cpna-2", "egl-21", "ram-2", "inos-1"))
{% endhighlight %}




<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_umap_gene_markers.png" width= 760>
  </div>

<div class= "panel panel-info">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Faster clustering with UMAP</h3>
</div>
<div class= "panel-body">
<p>If you have a relatively large dataset (with >10,000 cells or more), you may want to take advantage of options that can accelerate UMAP. Passing <code>umap.fast_sgd=TRUE</code> to <code>reduce_dimension()</code> will use a fast stochastic gradient descent method inside of UMAP. If your computer has multiple cores, you can use the <code>cores</code> argument to make UMAP multithreaded. However, invoking <code>reduce_dimension()</code> with either of these options will make it produce slighly different output each time you run it. If this is acceptable to you, you could see signifant reductions in the running time of <code>reduction_dimension()</code>.</p>
</div>
</div>

<p>If you want, you can also use t-SNE to visualize your data. First, call reduce_dimension with <code>reduction_method="tSNE"</code>.</p>
{% highlight R %}
cds = reduce_dimension(cds, reduction_method="tSNE")
{% endhighlight %}

<p>Then, when you call <code>plot_cells()</code>, pass <code>reduction_method="tSNE"</code> to it as well:</p>

{% highlight R %}
plot_cells(cds, reduction_method="tSNE", color_cells_by="cao_cell_type")
{% endhighlight %}

<p>You can actually use UMAP and t-SNE on the same <code>cds</code> object - one won't overwrite the results of the other. But you must specify which one you want in downstream functions like <code>plot_cells</code>.</p>

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_tsne_corrected_cao_type.png" width= 760>
</div>

<h3>Check for and remove batch effects</h3>
When performing gene expression analysis, it's important to check for <emph>batch effects</emph>, which are systematic differences in the transcriptome of cells measured in different experimental batches. These could be technical in nature, such as those introduced during the single-cell RNA-seq protocol, or biological, such as those that might arise from different litters of mice. How to recognize batch effects and account for them so that they don't confound your analysis can be a complex issue, but Monocle provides tools for dealing with them.

<p>You should always check for batch effects when you perform dimensionality reduction. You should add a column to the <code>colData</code> that encodes which batch each cell is from. Then you can simply color the cells by batch. Cao & Packer et al included a "plate" annotation in their data, which specifies which sci-RNA-seq plate each cell originated from. Coloring the UMAP by plate reveals:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="plate", label_cell_groups=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_plate.png" width= 760>
</div>

<p>Dramatic batch effects are not evident in this data. If the data contained more substantial variation due to plate, we'd expect to see groups of cells that really only come from one plate. Nevertheless, we can try and remove what batch effect is by re-running the <code>preprocess_cds()</code> function: </p>

{% highlight R %}
cds = preprocess_cds(cds, num_dim = 100, residual_model_formula_str = "~ plate")
cds = reduce_dimension(cds)
plot_cells(cds, color_cells_by="plate", label_cell_groups=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_plate.png" width= 760>
</div>

<h3>Group cells into clusters</h3>
Grouping cells into clusters is an important step in identifying the cell types represented in your data. Monocle uses a technique called <a href="https://en.wikipedia.org/wiki/Louvain_Modularity">Louvain community detection</a> to group cells. This approach was introduced by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4508757/">Levine et al</a> as part of the phenoGraph algorithm. You can cluster your cells using the <code>cluster_cells()</code> function, like this:

{% highlight R %}
cds = cluster_cells(cds, resolution=c(10^seq(-6,-1)))
plot_cells(cds)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_color_by_cluster.png" width= 760>
</div>

<p>Note that now when we call <code>plot_cells()</code> with no arguments, it colors the cells by cluster according to default.</p>
<p>The <code>cluster_cells()</code> also divides the cells into larger, more well separated groups called <emph>partitions</emph>, using a statistical test from <a href=https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x">Alex Wolf et al</a>, introduced as part of their <a href="https://github.com/theislab/paga">PAGA</a> algorithm. You can visualize these partitions like this:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="partition", group_cells_by="partition")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_color_cells_by_partition.png" width= 760>
</div>

<p>Once you run <code>cluster_cells()</code>, the <code>plot_cells()</code> function will label each cluster of cells is labeled separately according to how you want to color the cells. For example, the call below colors the cells according to their cell type annotation, and each cluster is labeled according the most common annotation within it:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="cao_cell_type")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_cao_type.png" width= 760>
</div>


<p></p>
You can choose to label whole partitions instead of clusters by passing <code>group_cells_by="partition"</code>. You can also plot the top 2 labels per cluster by passing <code>labels_per_group=2</code> to <code>plot_cells()</code>. Finally, you can disable this labeling policy, making <code>plot_cells()</code> behave like it did before we called <code>cluster_cells()</code>, like this:</p>


{% highlight R %}
plot_cells(cds, color_cells_by="cao_cell_type", label_groups_by_cluster=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_cao_type_no_cluster_label.png" width= 760>
</div>

<!--

{% highlight R %}
pheatmap::pheatmap(log(table(clusters(cds), colData(cds)$cao_cell_type)+1),
                   clustering_method="ward.D2",
                   fontsize=6)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_cell_type_by_cluster.png" width= 760>
</div> -->

<h3>Find marker genes expressed by each cluster</h2>

<p>Once cells have been clustered, we can ask what genes makes them different from one another. To do that, start by calling the <code<>top_markers()</code> function:</p>

{% highlight R %}
marker_test_res = top_markers(cds, group_cells_by="partition", reference_cells=1000, cores=8)
{% endhighlight %}

<p></p>The data frame <code>marker_test_res</code> contains a number of metrics for how specifically expressed each gene is in each partition. We could group the cells according to cluster, partition, or any categorical variable in <code>colData(cds)</code>. You can rank the table according to one or more of the specificity metrics and take the top gene for each cluster. For example, <code>pseudo_R2</code> is one such measure. We can rank markers according to <code>pseudo_R2</code> like this:

{% highlight R %}
top_specific_markers = marker_test_res %>%
    filter(fraction_expressing >= 0.10) %>%
    group_by(cell_group) %>%
    top_n(1, pseudo_R2)

top_specific_marker_ids = unique(top_specific_markers %>% pull(gene_id))

{% endhighlight %}

<p>Now, we can plot the expression and fraction of cells that express each marker in each group with the <code>plot_genes_by_group</code> function:</p>

{% highlight R %}
plot_genes_by_group(cds,
                    top_specific_marker_ids,
                    group_cells_by="partition",
                    ordering_type="maximal_on_diag",
                    max.size=3)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_top_partition_marker.png" width= 760>
</div>

<p>It's often informative to look at more than one marker, which you can do just by changing the first argument to <code>top_n()</code>:</p>
{% highlight R %}
top_specific_markers = marker_test_res %>%
    filter(fraction_expressing >= 0.10) %>%
    group_by(cell_group) %>%
    top_n(3, pseudo_R2)

top_specific_marker_ids = unique(top_specific_markers %>% pull(gene_id))

plot_genes_by_group(cds,
                    top_specific_marker_ids,
                    group_cells_by="partition",
                    ordering_type="cluster_row_col",
                    max.size=3)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_top3_partition_marker.png" width= 760>
</div>

There are many ways to compare and contrast clusters (and other groupings) of cells. We will explore them in great detail in the <a href = "{{
  site.baseurl }}/docs/#differential-expression-analysis">Differential expression analysis</a> section a bit later.

<h3>Annotate your cells according to type</h2>

<p>Identifying the type of each cell in your dataset is critical for many downstream analyses. There are several ways of doing this. One commonly used approach is to first cluster the cells and then assign a cell type to each cluster based on its gene expression profile. We've already seen how to use <code>top_markers()</code>. Reviewing literature associated with a marker gene often give strong indications of the identity of clusters that express it. In Cao & Packer <emph>>et al</emph>, the authors consulted literature and gene expression databases for markers restricted to each cluster in order to assign the identities contained in <code>colData(cds)$cao_cell_type</code>.</p>

<p>To assign cell types based on clustering, we begin by creating a new column in <code>colData(cds)</code> and initialize it with the values of <code>clusters(cds)</code>:</p>

{% highlight R %}
colData(cds)$assigned_cell_type = as.character(partitions(cds))
{% endhighlight %}

<p>Now, we can use the <code>dplyr</code>package's <code>recode()</code> function to remap each cluster to a different cell type:</p>
{% highlight R %}
colData(cds)$assigned_cell_type = dplyr::recode(colData(cds)$assigned_cell_type,
                                                "1"="Body wall muscle",
                                                "2"="Germline",
                                                "3"="Unclassified neurons",
                                                "4"="Seam cells",
                                                "5"="Coelomocytes",
                                                "6"="Pharyngeal epithelia",
                                                "7"="Vulval precursors",
                                                "8"="Non-seam hypodermis",
                                                "9"="Intestinal/rectal muscle",
                                                "10"="Touch receptor neurons",
                                                "11"="Pharyngeal neurons",
                                                "12"="Am/PH sheath cells",
                                                "13"="NA",
                                                "14"="Unclassified neurons",
                                                "15"="flp-1(+) interneurons",
                                                "16"="Canal associated neurons",
                                                "17"="Pharyngeal gland",
                                                "18"="Other interneurons",
                                                "19"="Ciliated sensory neurons",
                                                "20"="Ciliated sensory neurons",
                                                "21"="Ciliated sensory neurons",
                                                "22"="Ciliated sensory neurons",
                                                "23"="Ciliated sensory neurons",
                                                "24"="Ciliated sensory neurons",
                                                "25"="Oxygen sensory neurons",
                                                "26"="Ciliated sensory neurons",
                                                "27"="Unclassified neurons",
                                                "28"="Pharyngeal gland",
                                                "29"="Ciliated sensory neurons",
                                                "30"="Ciliated sensory neurons",
                                                "31"="Ciliated sensory neurons",
                                                "32"="Ciliated sensory neurons",
                                                "33"="Pharyngeal muscle",
                                                "34"="Failed QC")
{% endhighlight %}

<p>Let's see how the new annotations look:</p>
{% highlight R %}
plot_cells(cds, group_cells_by="partition", color_cells_by="assigned_cell_type")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_cells_by_initial_annotation.png" width= 760>
</div>

<p>Partition 7 has some substructure, and it's not obvious just from looking at the output of <code>top_markers()</code> what cell type or types it corresponds to. So we can isolate it with the <code>choose_cells()</code> function for further analysis:</p>

{% highlight R %}
cds_subset = choose_cells(cds)
{% endhighlight %}

<!--
I made choose_cells_recording by:
1) Using quicktime to screen record my interaction with the choose_cells shiny app
2) saving the MOV file to the manual_image directory.
3) Converting it to a GIF using instructions found here: https://gist.github.com/dergachev/4627207
ffmpeg -i in.mov -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > out.gif
-->

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/choose_cells_recording.gif" width= 760>
</div>

<p>Now we have a smaller <code>cell_data_set</code> object that contains just the cells from the partition we'd like to drill into. We can use <code>graph_test()</code> to identify genes that are differentially expressed in different subsets of cells from this partition:</p>

{% highlight R %}
pr_graph_test_res = graph_test(cds_subset, neighbor_graph="knn", cores=8)
pr_deg_ids = row.names(subset(pr_graph_test_res, morans_I > 0.01 & q_value < 0.05))
{% endhighlight %}

<p>We will learn more about <code>graph_test()</code> in the <a href = "{{
  site.baseurl }}/docs/#finding-modules-of-co-regulated-genes">Differential expression analysis</a> section later. We can take all the genes that vary across this set of cells and group those that have similar patterns of expression into <emph>modules</emph>: </p>

{% highlight R %}
gene_module_df = find_gene_modules(cds_subset[pr_deg_ids,], resolution=1e-3)
{% endhighlight %}

<p>Plotting these modules' aggregate expression values reveals which cells express which modues. </p>
{% highlight R %}
plot_cells(cds_subset, genes=gene_module_df, show_trajectory_graph=FALSE, label_cell_groups=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_sex_partition_modules.png" width= 760>
</div>

<p>You can explore the genes in each module or conduct <a href="http://geneontology.org/">gene ontology enrichment analysis</a> on them to glean insights about which cell types are present. Suppose after doing this we have a good idea of what the cell types in the partition are. Let's see how they overlap with the clusters in the partition:</p>

{% highlight R %}
plot_cells(cds_subset, color_cells_by="cluster")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_sex_partition_color_by_cluster.png" width= 760>
</div>

<p>Based on how the patterns line up, we'll make the following assignments:</p>
{% highlight R %}
colData(cds_subset)$assigned_cell_type = as.character(clusters(cds_subset)[colnames(cds_subset)])
colData(cds_subset)$assigned_cell_type = dplyr::recode(colData(cds_subset)$assigned_cell_type,
                                                      "30"="Vulval precursors",
                                                      "65"="Distal tip cells",
                                                      "24"="Sex myoblasts",
                                                      "51"="Sex myoblasts",
                                                      "33"="Somatic gonad progenitors")
plot_cells(cds_subset, group_cells_by="cluster", color_cells_by="assigned_cell_type")
{% endhighlight %}

<p>Now we can transfer the annotations from the <code>cds_subset</code> object back to the full dataset. We'll also filter out low-quality cells at this stage</p>

{% highlight R %}
colData(cds)[colnames(cds_subset),]$assigned_cell_type = colData(cds_subset)$assigned_cell_type
cds = cds[,colData(cds)$assigned_cell_type != "Failed QC" | is.na(colData(cds)$assigned_cell_type )]
plot_cells(cds, group_cells_by="partition", color_cells_by="assigned_cell_type", labels_per_group=5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_cells_by_refined_annotation.png" width= 760>
</div>

<h3>Automated annotation with Garnett</h3>

<p>The above process for manually annotating cells by type can be laborious, and must be re-done if the underlying cluster changes. We recently developed <a href="https://cole-trapnell-lab.github.io/garnett/">Garnett</a>, a software toolkit for automatically annotating cells. Garnett classifies cells based on marker genes. If you've gone through the trouble of annotated your cells manually, Monocle can generate a file of marker genes that can be used with Garnett. This will help you annotate other datasets in the future or reannotate this one if you refine your analysis and update your clustering in the future.</p>

<p>To generate a Garnett file, first find the top markers that each annotated cell type expresses:</p>
{% highlight R %}
assigned_type_marker_test_res = top_markers(cds,
                                            group_cells_by="assigned_cell_type",
                                            reference_cells=1000,
                                            cores=8)
{% endhighlight %}

<p>Next, filter these markers according to how stringent you want to be:</p>
{% highlight R %}
# Require that markers have at least JS specificty score > 0.5 and
# be significant in the logistic test for identifying their cell type:
garnett_markers = assigned_type_marker_test_res %>%
    filter(marker_test_q_value < 0.01 & specificity >= 0.5) %>%
    group_by(cell_group) %>%
    top_n(5, marker_score)
# Exclude genes that are good markers for more than one cell type:
garnett_markers = garnett_markers %>% group_by(gene_short_name) %>%
    filter(n() == 1)
{% endhighlight %}

<p>Then call <code>generate_garnett_marker_file</code>:</p>
{% highlight R %}
generate_garnett_marker_file(garnett_markers, file="./marker_file.txt")
{% endhighlight %}

<p><code>generate_garnett_marker_file</code></p> will produce a text file like this:
{% highlight console %}
> Cell type Ciliated sensory neurons
expressed: che-3, scd-2, C33A12.4, R102.2, F27C1.11

> Cell type Non-seam hypodermis
expressed: col-14, col-180, F11E6.3, grsp-1, C06A8.3

> Cell type Seam cells
expressed: col-65, col-77, col-107, ram-2, Y47D7A.13

> Cell type Vulval precursors
expressed: col-68, col-145, lin-31, osm-11, Y62E10A.19

> Cell type Body wall muscle
expressed: csq-1, hum-9, cpna-2, tag-278, F41C3.5

> Cell type Coelomocytes
expressed: cup-4, inos-1, Y73F4A.1, ZC116.3, aman-1

> Cell type flp-1 interneurons
expressed: daf-10, flp-1, nlp-10, zig-2, H05L03.3

> Cell type Sex myoblasts
expressed: egl-15, C04E12.2

> Cell type Intestinal/rectal muscle
expressed: egl-20, lbp-2, bgal-1, ttr-10, T23B12.8

> Cell type Am/PH sheath cells
expressed: far-8, F35B12.9, ZK822.4, F20A1.1, T02B11.3

> Cell type Oxygen sensory neurons
expressed: flp-17, gcy-9, gcy-33, ist-1, Y57G11B.97

> Cell type Pharyngeal neurons
expressed: flr-2, nlp-6, F14B6.2, degt-1, flp-28

> Cell type Unclassified neurons
expressed: gar-2, madd-4, twk-49

> Cell type Germline
expressed: gld-1, pgl-1, ppw-2, prg-2, cbd-1

> Cell type Somatic gonad precursors
expressed: inx-9, mnm-2, C36B7.4

> Cell type Touch receptor neurons
expressed: mec-1, mec-7, mec-12, mec-17, mec-18

> Cell type Pharyngeal epithelia
expressed: pgp-14, pqn-74, fipr-2, R03C1.1, Y73F4A.2

> Cell type Pharyngeal muscle
expressed: pqn-29, F31D4.5, R13H4.8, T01B7.8, T20B6.3

> Cell type Pharyngeal gland
expressed: F15A4.6, dod-6, C49G7.3, M04G7.1, phat-4

> Cell type Canal associated neurons
expressed: acbp-6, Y66D12A.14, ZC412.4, C32E8.6, C41A3.1
{% endhighlight %}

<p>The marker files produced by <code>generate_garnett_marker_file()</code> are just a starting point for classifying your cells with Garnett. You may want to edit this file to add or remove markers based on literature or other information. You also should consider defining subtypes of cells, which can greatly increase the usefulness and accuracy of Garnett. For example, the L2 data contains many different types of neurons. Making a "Neuron" cell type in the file above and then using the <code>subtype of</code> keyword to organize the various subtypes of neurons will make Garnett more able to recognize them and distinguish them from non-neuronal cell types. When two or more of your cell types share most of their top markers in <code>plot_genes_by_group()</code>, consider defining a broader cell type definition of which they are both subtypes. You might also want to define markers for the various subtypes of neurons by subsetting the <code>cds</code> object above and running <code>top_markers()</code> just on them. See the Garnett <a href="https://cole-trapnell-lab.github.io/garnett/docs/">documentation</a> for more on how you can enrich your marker files.</p>

<p>When you're ready run Garnett, load the package:</p>

<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Garnett for Monocle 3</h3>
</div>
<div class= "panel-body">
<p>Garnett was originally written to work with Monocle 2. We have created a branch
    of Garnett that works with Monocle 3, which will eventually replace the
    main branch. In the meantime, you must install and load the Monocle 3 branch of
    Garnett!</p>
</div>
</div>
{% highlight R %}
## Install the monocle3 branch of garnett
devtools::install_github("cole-trapnell-lab/garnett", ref="monocle3")
{% endhighlight %}

{% highlight R %}
library(garnett)
{% endhighlight %}

<p>Now train a Garnett classifier based on your marker file like this:</p>
{% highlight R %}
colData(cds)$garnett_cluster = clusters(cds)
worm_classifier <- train_cell_classifier(cds = cds,
                                         marker_file = "./marker_file.txt",
                                         db=org.Ce.eg.db::org.Ce.eg.db,
                                         cds_gene_id_type = "ENSEMBL",
                                         num_unknown = 50,
                                         marker_file_gene_id_type = "SYMBOL",
                                         cores=8)
{% endhighlight %}

<p>Now that we've trained a classifier <code>worm_classifier</code>, we can use it to annotate the L2 cells according to type:</p>
{% highlight R %}
cds = classify_cells(cds, worm_classifier,
                           db = org.Ce.eg.db::org.Ce.eg.db,
                           cluster_extend = TRUE,
                           cds_gene_id_type = "ENSEMBL")
{% endhighlight %}

<p>Here's how Garnett annotated the cells:</p>

{% highlight R %}
plot_cells(cds,
           group_cells_by="partition",
           color_cells_by="cluster_ext_type")
{% endhighlight %}

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_garnett_ext_type.png" width= 760>
</div>

<p>Garnett classifiers can be applied to datasets other than the one they were trained on. We strongly encourage you to <a href="https://cole-trapnell-lab.github.io/garnett/docs/#submitting-a-classifier">share</a> your Garnett files and include them with your papers so that others can use them.</p>

<p>As part of writing a paper about Garnett, we trained a Garnett model to classify <emph>C. elegans</emph> cells based on the L2 data. You can classify cells with it by first downloading and then passing it to the <code>classify_cells()</code> function:</p>

{% highlight R %}
load(url("https://cole-trapnell-lab.github.io/garnett/classifiers/ceWhole"))
cds = classify_cells(cds, ceWhole,
                           db = org.Ce.eg.db,
                           cluster_extend = TRUE,
                           cds_gene_id_type = "ENSEMBL")
{% endhighlight %}

<!-- {% highlight R %}
# Plot the overlap between clusters and annotated cell types:
pheatmap::pheatmap(log(table(partitions(cds), colData(cds)$cao_cell_type)+1),
                   clustering_method="ward.D2",
                   fontsize=6, width=5, height=8, filename="L2_cell_type_by_partition.png")
{% endhighlight %} -->

<h2>Constructing single-cell trajectories </h2>

<p>   During development, in response to stimuli, and throughout life, cells
transition from one functional "state" to another. Cells in different states
express different sets of genes, producing a dynamic repetoire of proteins and
metabolites that carry out their work. As cells move between states, they undergo a
process of transcriptional re-configuration, with some genes being silenced and
others newly activated. These transient states are often hard to characterize
because purifying cells in between more stable endpoint states can be difficult
or impossible. Single-cell RNA-Seq can enable you to see these states without
the need for purification. However, to do so, we must determine where each cell
is in the range of possible states. </p>

<p>   Monocle introduced the strategy of using RNA-Seq for <em>single-cell
trajectory analysis</em>. Rather than purifying cells into discrete states
experimentally, Monocle uses an algorithm to learn the sequence of gene
expression changes each cell must go through as part of a dynamic biological
process. Once it has learned the overall "trajectory" of gene expression
changes, Monocle can place each cell at its proper position in the trajectory.
You can then use Monocle's differential analysis toolkit to find genes regulated
over the course of the trajectory, as described in the section <a href = "{{
site.baseurl }}/monocle3_docs/#finding-genes-that-change-as-a-function-of-pseudotime">
Finding genes that change as a function of pseudotime </a>. If there are
multiple outcomes for the process, Monocle will reconstruct a "branched"
trajectory. These branches correspond to cellular "decisions", and Monocle
provides powerful tools for identifying the genes affected by them and involved
in making them. You can see how to analyze branches in the section <a href = "{{
site.baseurl }}/monocle3_docs/#analyzing-branches-in-single-cell-trajectories"> Analyzing
branches in single-cell trajectories </a>.

<!-- Monocle relies on a machine learning
technique called <em>reversed graph embedding</em> to construct single-cell
trajectories. You can read more about the theoretical foundations of Monocle's
approach in the section <a href = "{{ site.baseurl }}/docs/#theory-behind-monocle">
Theory Behind Monocle </a> , or consult the references shown at the end of the
vignette.  -->
</p>

The workflow for reconstructing trajectories is very similar to the workflow for clustering, but it has a few additional steps. To illustrate the workflow, we will use another <emph>C. elegans</emph> data set, this one from <a href="http://dx.doi.org/10.1101/565549">Packer & Zhu et al</a>. Their study includes a time series analysis of whole developing embyros. We will examine a small subset of the data which includes most of the neurons. We will load it as we did with the L2 data:

{% highlight R %}
expression_matrix = readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_expression.rds"))
cell_metadata = readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_colData.rds"))
gene_annotation = readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_rowData.rds"))

cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
{% endhighlight %}

<h3>Pre-process the data</h3>
<p>Pre-processing works exactly as in clustering analysis. This time, we will use a different strategy for batch correction, which replicates what <emph>Packer & Zhu et al</emph> did in their original analysis:</p>

{% highlight R %}
cds <- preprocess_cds(cds, num_dim = 100, residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading")
{% endhighlight %}

<h3>Reduce dimensionality and visualize the results</h3>
Next, we reduce the dimensionality of the data. However, unlike clustering, which works well with both UMAP and t-SNE, here we strongly urge you to use UMAP, the default method:

{% highlight R %}
cds <- reduce_dimension(cds)
plot_cells(cds, label_groups_by_cluster=FALSE,  color_cells_by = "cell.type")
{% endhighlight %}

<p>As you can see, despite the fact that we are only looking at a small slice of this dataset, Monocle reconstructs a trajectory with numerous branches. Overlaying the manual annotations on the UMAP reveals that these branches are pricipally occupied by one cell type.

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_packer_cell_type.png" width= 760>
</div>

<p>As with clustering analysis, you can use <code>plot_cells()</code> to visualize how individual genes vary along the trajectory. Let's look at some genes with interesting patterns of expression in ciliated neurons:</p>
{% highlight R %}
ciliated_genes = c("che-1",
                   "hlh-17",
                   "nhr-6",
                   "dmd-6",
                   "ceh-36",
                   "ham-1")

plot_cells(cds,
           genes=ciliated_genes,
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_ciliated_markers.png" width= 760>
</div>

<p>We will learn how to identify the genes that are restricted to each outcome of the trajectory later on in the section <a href = "{{
  site.baseurl }}/monocle3_docs/#finding-genes-that-change-as-a-function-of-pseudotime">
  Finding genes that change as a function of pseudotime</a>.</p>


<h3>Cluster your cells </h3>
<p>Although cells may continuously transition from one state to the next with no discrete boundary between them, Monocle does not assume that all cells in the dataset descend from a common transcriptional "ancestor". In many experiments, there might in fact be multiple distinct trajectories. For example, in a tissue responding to an infection, tissue resident immune cells and stromal cells will have very different initial transcriptomes, and will respond to infection quite differently, so they should be a part of the same trajectory. </p>

<p>Monocle is able to learn when cells should be placed in the same trajectory as opposed to separate trajectories through its clustering procedure. Recall that we run <code>cluster_cells()</code>, each cell is assigned not only to a cluster but also to a <emph>partition</emph>. When you are learning trajectories, each partition will eventually become a separate trajectory. We run <code>cluster_cells()</code>as before.</p>
{% highlight R %}
cds <- cluster_cells(cds)
plot_cells(cds, color_cells_by = "partition")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_partition.png" width= 760>
</div>

<h3>Learn the trajectory graph</h3>
Next, we will fit a <emph>principal graph</emph> within each parition using the <code>learn_graph()</code> function:
{% highlight R %}
cds <- learn_graph(cds)
plot_cells(cds,
           color_cells_by = "cell.type",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_packer_cell_type.png" width= 760>
</div>

This graph will be used in many downstream steps, such as branch analysis and differential expression.

<h3>Order the cells in pseudotime</h3>
Once we've learned a graph, we are ready to order the cells according to their progress through the developmental program. Monocle measures this progress in <emph>pseudotime</emph>. The box below defines pseudotime.

<div class= "panel panel-info">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>What is pseudotime?</h3>
</div>
<div class= "panel-body">
<p><emph>Pseudotime</emph> is a measure of how much progress an individual cell has made through a process such as cell differentiation. </p>

<p>In many biological processes, cells do not progress in perfect synchrony.  In single-cell expression studies of processes such as cell differentiation, captured cells might be widely distributed in terms of progress.  That is, in a population of cells captured at exactly the same time, some cells might be far along, while others might not yet even have begun the process.  This asynchrony creates major problems when you want to understand the sequence of regulatory changes that occur as cells transition from one state to the next. Tracking the expression across cells captured at the same time produces a very compressed sense of a gene's kinetics, and the apparent variability of that gene's expression will be very high.</p>

<p>By ordering each cell according to its progress along a learned trajectory, Monocle alleviates the problems that arise due to asynchrony. Instead of tracking changes in expression as a function of time, Monocle tracks changes as a function of progress along the trajectory, which we term ``pseudotime''. Pseudotime is an abstract unit of progress: it's simply the distance between a cell and the start of the trajectory, measured along the shortest path. The trajectory's total length is defined in terms of the total amount of transcriptional change that a cell undergoes as it moves from the starting state to the end state.</p>
</div>
</div>

<p>In order to place the cells in order, we need to tell Monocle where the "beginning" of the biological process is. We do so by chosing regions of the graph that we mark as "roots" of the trajectory. In time series experiments, this can usually be accomplished by finding spots in the UMAP space that are occupied by cells from early time points:</p>
{% highlight R %}
plot_cells(cds,
           color_cells_by = "embryo.time.bin",
           label_cell_groups=FALSE,
           label_leaves=TRUE,
           label_branch_points=TRUE,
           graph_label_size=1.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_by_time.png" width= 760>
</div>

<p>The black lines show the structure of the graph. Note that the graph is not fully connected: cells in different partitions are in distinct components of the graph. The circles with numbers in them denote special points within the graph. Each <emph>leaf</emph>, denoted by light gray circles, corresponds to a different outcome (i.e. cell fate) of the trajectory. Black circles indicate branch nodes, in which cells can travel to one of several outcomes. You can control whether or not these are shown in the plot with the <code>label_leaves</code> and <code>label_branch_points</code> arguments to <code>plot_cells</code>.</p>

<p>Now that we have a sense of where the early cells fall, we can call <code>order_cells()</code>, which will calculate where each cell falls in pseudotime. In order to do so <code>order_cells()</code>needs you to specify the <emph>root nodes</emph> of the trajectory graph. If you don't provide them as an argument, it will launch a graphical user interface for selecting or or more root nodes.</p>

{% highlight R %}
cds = order_cells(cds)
{% endhighlight %}

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/choose_root_recording.gif" width= 760>
</div>

<p>In the above example, we just chose one location, but you could pick as many as you want. Plotting the cells and coloring them by pseudotime shows how they were ordered:</p>

{% highlight R %}
plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_by_pseudotime.png" width= 760>
</div>
<p>Note that some of the cells are gray. This means they have <emph>infinite</emph> pseudotime, because they were not reachable from the root nodes that were picked. In general, any cell on a parition that lacks a root node will be assigned an infinite pseudotime. In general, you should choose at least one root per partition.</p>

<p>It's often desirable to specify the root of the trajectory programmatically, rather than manually picking it. The function below does so by first grouping the cells according to which trajectory graph node they are nearest to. Then, it calcuates what fraction of the cells at each node come from the earliest time point. Then it picks the node that is most heavily occupied by early cells and returns that as the root.</p>

{% highlight R %}
# a helper function to identify the root principal points:
get_earliest_principal_node <- function(cds, time_bin="130-170"){
  cell_ids <- which(colData(cds)[, "embryo.time.bin"] == time_bin)

  closest_vertex <-
    cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
    igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
      (which.max(table(closest_vertex[cell_ids,]))))]

  root_pr_nodes
}
cds = order_cells(cds, root_pr_nodes=get_earliest_principal_node(cds))
{% endhighlight %}

<p>Passing the programatically selected root node to <code>order_cells()</code> via the <code>root_pr_node</code>argument yields:
{% highlight R %}
plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_by_pseudotime_programmatically_ordered.png" width= 760>
</div>

<p>Note that we we could easily do this on a per-partition basis by first grouping the cells by partition using the <code>partitions()</code> function. This would result in all cells being assigned a finite pseudotime.

<h3>Working with 3D trajectories</h3>

{% highlight R %}
cds_3d = reduce_dimension(cds, max_components = 3)
cds_3d = cluster_cells(cds_3d)
cds_3d = learn_graph(cds_3d)
cds_3d = order_cells(cds_3d, root_pr_nodes=get_earliest_principal_node(cds))

cds_3d_plot_obj = plot_cells_3d(cds_3d, color_cells_by="partition")
{% endhighlight %}

<strong>XXX PUT 3D PLOT BACK!!</strong>

<!-- <iframe src="{{site.baseurl}}/images/manual_images/emb_3d_by_partition.html"
  height="600" width="100%"
  scrolling="no" seamless="seamless"
  frameBorder="0">
</iframe>
 -->


<h2>Differential expression analysis </h2>
Differential gene expression analysis is a common task in RNA-Seq experiments.  Monocle can help you find genes that are differentially expressed between groups of cells and assesses the statistical signficance of those changes. Monocle 3 includes a powerful system for finding genes that vary across cells of different types, were collected at different developmental time points, or that have been perturbed in different ways.

<p>There are two approaches for differential analysis in Monocle:</p>
<ul>
  <li><strong>Regression analysis</strong>: using <code>fit_models()</code>, you can evaluate whether each gene depends on variables such as time, treatments, etc.</li>
  <li><strong>Graph-autocorrelation analysis</strong>: using <code>graph_test()</code>, you can find genes that vary over a trajectory or between clusters.</li>
</ul>

<p>Monocle also comes with specialized functions for finding co-regulated modules of differentially expressed genes. Monocle also allows you to interactively interrogate specific clusters or regions of a trajectory (e.g. branch points) for genes that vary within them.

<p>Let's examine these tools in turn.</p>

<h3>Regression analysis </h3>
<p> In this section, we'll explore how to use Monocle to find genes that are differentially expressed according to several different criteria. Performing differential expression analysis on all genes in a <a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a> object can take anywhere from minutes to hours, depending on how complex the analysis is. To keep the vignette simple and fast, we'll be working with small sets of genes. Rest assured, however, that Monocle can analyze several thousands of genes even in large experiments, making it useful for discovering dynamically regulated genes during the biological process you're studying. </p>

<p> Let's begin with a small set of genes that we know are important in ciliated neurons to demonstrate Monocle's capabilities:</p>

{% highlight R %}
ciliated_genes = c("che-1",
                   "hlh-17",
                   "nhr-6",
                   "dmd-6",
                   "ceh-36",
                   "ham-1")
cds_subset = cds[rowData(cds)$gene_short_name %in% ciliated_genes,]
{% endhighlight %}

<p></p>The differential analysis tools in Monocle are extremely flexible. Monocle works by fitting a <emph>regression model</emph> to each gene. You can specify this model to account for various factors in your experiment (time, treatment, and so on). For example, In the embryo data, the cells were collected at different time points. We can test whether any of the genes above change over time in their expression by first fitting a <emph>generalized linear model</emph> to each one: </p>

\begin{equation}
  log(y_i) = \beta_0 + \beta_t x_t
\end{equation}

<p>where $y_i$ is a random variable corresponding to the expression values of gene $i$, $x_t$ is the time each cell was collected (in minutes), and the $\beta_t$ capture the effect of time on expression, and $\beta_0$ is an intercept term. We can identify genes that vary over time by fitting this model to each one, and then testing whether it's $\beta_t$ is significantly different from zero. To do so, we first call the <code>fit_models()</code> function:</p>

{% highlight R %}
gene_fits = fit_models(cds_subset, model_formula_str = "~embryo.time")
{% endhighlight %}

<p><code>gene_fits</code> is a <a href="https://tibble.tidyverse.org/">tibble</a> that contains a row for each gene. The <code>model</code> column contains generalized linear model objects, each of which aims to explain the expression of a gene across the cells using the equation above. The parameter <code>model_formula_str</code> should be a string specifying the model formula. The model formulae you use in your tests can include any term that exists as a column in the <code>colData</code> table, including those columns that are added by Monocle in other analysis steps. For example, if you use <code><a href = "https://rdrr.io/bioc/monocle/man/cluster_cells.html">cluster_cells</a></code>, you can test for genes that differ between clusters and partitions by using <code>~cluster</code> or <code>~partition</code> (respectively) as your model formula. You can also include multiple variables, for example  <code>~embryo.time + batch</code>, which can be very helpful for subtracting unwanted effects.

<p> Now let's see which of these genes have time-dependent expression. First, we extract a table of coefficients from each model using the <code>coefficient_table()</code> function:</p>
{% highlight R %}
fit_coefs = coefficient_table(gene_fits)
{% endhighlight %}

<p></p><code>fit_coefs</code> looks like this: </p>

<div style="width:750px; height:250px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>id</th>
    <th>gene_short_name</th>
    <th>num_cells_expressed</th>
    <th>status</th>
    <th>term</th>
    <th>estimate</th>
    <th>std_err</th>
    <th>test_val</th>
    <th>p_value</th>
    <th>normalized_effect</th>
    <th>model_component</th>
    <th>q_value</th>
    </tr>
    </thead>
    <tbody>
  {% for term in site.data.de_tests.emb_terms %}
    <tr>
    <td>{{ term.id }}</td>
    <td>{{ term.gene_short_name }}</td>
    <td>{{ term.num_cells_expressed }}</td>
    <td>{{ term.status }}</td>
    <td>{{ term.term }}</td>
    <td>{{ term.estimate }}</td>
    <td>{{ term.std_err }}</td>
    <td>{{ term.test_val }}</td>
    <td>{{ term.p_value }}</td>
    <td>{{ term.normalized_effect }}</td>
    <td>{{ term.model_component }}</td>
    <td>{{ term.q_value }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<p>Note that the table includes one row for each <emph>term</emph> of each gene's model. We generally don't care about the intercept term $\beta_0$, so we can easily just extract the time terms:</p>

{% highlight R %}
emb_time_terms = fit_coefs %>% filter(term == "embryo.time")
{% endhighlight %}

<p>Now, let's pull out the genes that have a significant time component. <code>coefficient_table()</code> calculates tests each coefficient for whether it is significantly different than zero under the <a href="https://en.wikipedia.org/wiki/Wald_test">Wald test</a>. By default, <code>coefficient_table()</code> adjusts these p-values for <code<>multiple hypothesis testing</code> using the method of <a href="https://en.wikipedia.org/wiki/False_discovery_rate">Benjamini and Hochberg</a>. These adjusted values can be found in the <code>q_value</code> column. We can filter the results and control the false discovery rate as follows:

{% highlight R %}
emb_time_terms %>% filter (q_value < 0.05) %>%
  select(gene_short_name, term, q_value, estimate)
{% endhighlight %}

<div style="width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>gene_short_name</th>
    <th>term</th>
    <th>q_value</th>
    <th>estimate</th>
    </tr>
    </thead>
    <tbody>
  {% for term in site.data.de_tests.emb_time_sig_terms %}
    <tr>
    <td>{{ term.gene_short_name }}</td>
    <td>{{ term.term }}</td>
    <td>{{ term.q_value }}</td>
    <td>{{ term.estimate }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<p>We can see that five of the six genes significantly vary as a function of time. </p>

<p> Monocle also provides some easy ways to plot the expression of a small set of genes grouped by the factors you use during differential analysis.  This helps you visualize the differences revealed by the tests above.  One type of plot is a "violin" plot. </p>

{% highlight R %}
plot_genes_violin(cds_subset, group_cells_by="embryo.time.bin", ncol=2) +
    theme(axis.text.x=element_text(angle=45, hjust=1))
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_ciliated_markers_violin.png" width= 500>
</div>

<h3>Controlling for batch effects and other factors</h3>

<!-- TODO: Add violin plots in this section -->

{% highlight R %}
gene_fits = fit_models(cds_subset, model_formula_str = "~embryo.time + batch")
fit_coefs = coefficient_table(gene_fits)
fit_coefs %>% filter(term != "(Intercept)") %>%
  select(gene_short_name, term, q_value, estimate)
{% endhighlight %}

<div style="height: 250px; width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>gene_short_name</th>
    <th>term</th>
    <th>q_value</th>
    <th>estimate</th>
    </tr>
    </thead>
    <tbody>
  {% for term in site.data.de_tests.emb_plus_batch_terms %}
    <tr>
    <td>{{ term.gene_short_name }}</td>
    <td>{{ term.term }}</td>
    <td>{{ term.q_value }}</td>
    <td>{{ term.estimate }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<h3>Evaluating models of gene expression</h3>

<p>How good are these models at "explaining" gene expression? We can evaluate the fits of each model using the <code>evaluate_fits()</code> function:</p>

{% highlight R %}
evaluate_fits(gene_fits)
{% endhighlight %}

<div style="width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>id</th>
    <th>gene_short_name</th>
    <th>num_cells_expressed</th>
    <th>status</th>
    <th>null_deviance</th>
    <th>df.null</th>
    <th>logLik</th>
    <th>AIC</th>
    <th>BIC</th>
    <th>deviance</th>
    <th>df_residual</th>
    </tr>
    </thead>
    <tbody>
  {% for gene in site.data.de_tests.emb_time_evals %}
    <tr>
    <td>{{ gene.id }}</td>
    <td>{{ gene.gene_short_name }}</td>
    <td>{{ gene.num_cells_expressed }}</td>
    <td>{{ gene.status }}</td>
    <td>{{ gene.null_deviance }}</td>
    <td>{{ gene.df_null }}</td>
    <td>{{ gene.logLik }}</td>
    <td>{{ gene.AIC }}</td>
    <td>{{ gene.BIC }}</td>
    <td>{{ gene.deviance }}</td>
    <td>{{ gene.df_residual }}</td>
    </tr>
    <tr>
  {% endfor %}
    </tbody>
</table>
</div>

<p>Should we include the batch term in our model of gene expression or not? Monocle provides a function <code>compare_models()</code> that can help you decide. Compare models takes two models and returns the result of a <a href="https://en.wikipedia.org/wiki/Likelihood-ratio_test">likelihood ratio test</a> between them. Any time you add terms to a model, it will improve the fit. But we should always to use the simplest model we can to explain our data. The likelihood ratio test helps us decide whether the improvement in fit is large enough to justify the complexity our extra terms introduce. You run <code>compare_models()</code> like this:</p>

{% highlight R %}
time_batch_models = fit_models(cds_subset,
                               model_formula_str = "~embryo.time + batch",
                               expression_family="negbinomial")
time_models = fit_models(cds_subset,
                        model_formula_str = "~embryo.time",
                        expression_family="negbinomial")
compare_models(time_batch_models, time_models) %>% select(gene_short_name, q_value)
{% endhighlight %}

<p>The first of the two models is called the <em>full</em> model. This model is essentially a way of predicting the expression value of each gene in a given cell knowing both what time it was collected and which batch of cells it came from. The second model, called the <em>reduced</em> model, does the same thing, but it only knows about the time each cell was collected.  Because the full model has more information about each cell, it will do a better job of predicting the expression of the gene in each cell. The question Monocle must answer for each gene is <em>how much better</em> the full model's prediction is than the reduced model's. The greater the improvement that comes from knowing the <em>batch</em> of each cell, the more significant the result of the likelihood ratio test.</p>

<p>As we can see, all of the genes' likelihood ratio tests are significant, indicating that there are substantial batch effects in the data. We are therefore justified in adding the <code>batch</code> term to our model.</p>

<div style="height: 250px; width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>gene_short_name</th>
    <th>p_value</th>
    </tr>
    </thead>
    <tbody>
  {% for gene in site.data.de_tests.emb_model_lr_test %}
    <tr>
    <td>{{ gene.gene_short_name }}</td>
    <td>{{ gene.q_value }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<h3>Choosing a distribution for modeling gene expression</h3>
<p>Monocle uses <a href="https://en.wikipedia.org/wiki/Generalized_linear_model">generalized linear models</a> to capture how a gene's expression depends on each variable in the experiment. These models require you to specify a distribution that describes gene expression values. Most studies that use this approach to analyze their gene expression data use the <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">negative binomial distribution</a>, which is often appropriate for sequencing read or UMI count data. The negative binomial is at the core of many packages for RNA-seq analysis, such as <a href="https://bioconductor.org/packages/release/bioc/html/DESeq2.html">DESeq2</a>.

<p>Monocle's <code>fit_models()</code> supports the negative binomial distribution and several others listed in the table below. The default is the <a href="https://en.wikipedia.org/wiki/Poisson_regression">"quasipoisson"</a>, which is very similar to the negative binomial. Quasipoisson is a a bit less accurate than the negative binomial but much faster to fit, making it well suited to datasets with thousands of cells.</p>

There are several allowed values for <code>expression_family</code>:
</p>
<p>
<table class= "table">
<thead>
<tr>
<th>expression_family</th>
<th>Distribution</th>
<th>Accuracy</th>
<th>Speed</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>quasipoisson</code></td>
<td><a href="https://en.wikipedia.org/wiki/Poisson_regression">Quasi-poisson</a></td>
<td>++</td>
<td>++</td>
<td>Default for <code>fit_models()</code>. Recommended for  most users.</td>
</tr>
<tr>
<td><code>negbinomial</code></td>
<td><a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Negative binomial</a></td>
<td>+++</td>
<td>+</td>
<td>Recommended for users with small datasets (fewer than 1,000 cells).</td>
</tr>
<tr>
<td><code>poisson</code></td>
<td><a href="https://en.wikipedia.org/wiki/Poisson_regression">Poisson</a></td>
<td>-</td>
<td>+++</td>
<td>Not recommended. For debugging and testing only.</td>
</tr>
<tr>
<td><code>binomial</code></td>
<td><a href="https://en.wikipedia.org/wiki/Logistic_regression">Binomial</a></td>
<td>++</td>
<td>++</td>
<td>Recommended for single-cell ATAC-seq</td>
</tr>
<tr>
<!-- <td><code>gaussian</code></td>
<td>If you want to use Monocle on data you have already transformed to be normally distributed, you can use this function, though some Monocle features may not work well.</td>
</tr> -->
</tbody>
</table>
</p>

<p>
<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Likelihood based analysis and quasipoisson</h3>
</div>
<div class= "panel-body">
The quasi-poisson distribution doesn't have a real likelihood function, so some of Monocle's methods won't work with it. Several of the columns in results tables from <code>evaluate_fits()</code> and <code>compare_models()</code> will be <code>NA</code>.
</div>
</div>
</p>

<!-- <p>
<div class= "panel panel-danger">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Use the right distribution!</h3>
</div>
<div class= "panel-body">
<strong>Using the wrong expressionFamily for your data will lead to bad results</strong>, errors from Monocle, or both.
However, if you have FPKM/TPM data, you can still use negative binomial if you first convert your relative expression values to transcript counts using <code><a href = "https://rdrr.io/bioc/monocle/man/relative2abs.html">relative2abs()</a></code>.
This often leads to much more accurate results than using <code>tobit()</code>. See the section on  <a href = "{{ site.baseurl }}/docs/#converting-tpm-fpkm-values-into-mrna-counts-alternative"> Converting TPM to mRNA Counts</a> for details.
</div>
</div>
</p>
   -->

<!-- <h3 data-toc-text= "Choosing a distribution for your data">Choosing a distribution for your data <span class= "label label-danger">Required</span></h3>

<p> Monocle works well with both relative expression data and count-based measures (e.g. UMIs).
In general, it works best with transcript count data, especially UMI data.
Whatever your data type, it is <i>critical</i> that specify the appropriate distribution for it.
FPKM/TPM values are generally log-normally distributed, while UMIs or read counts are better modeled with the negative binomial.
To work with count data, specify the negative binomial distribution as the <code>expressionFamily</code> argument to <code><a href = "https://rdrr.io/bioc/monocle/man/new_cell_data_set.html">new_cell_data_set</a></code>: </p>
<p>
{% highlight R %}
#Do not run
HSMM <- new_cell_data_set(count_matrix,
      phenoData = pd,
      featureData = fd,
      expressionFamily=negbinomial.size())
{% endhighlight %}
</p>



<!--
  FIXME: Put this back when we have resolved https://github.com/cole-trapnell-lab/monocle3/issues/31
<h3>Finding Genes that Distinguish Cell Types </h3>

{%highlight R%}
to_be_tested <- row.names(subset(fData(HSMM),
    gene_short_name %in% c("UBC", "NCAM1", "ANPEP")))
cds_subset <- HSMM[to_be_tested,]
{%endhighlight%}

<p>However, we have to specify a <em>model formula</em> in the call to tell
Monocle that we care about genes with expression levels that depends on
<em>CellType</em>. Monocle's differential expression analysis works essentially
by fitting two models to the expression values for each gene, working through
each gene independently.

<p> To set up the test based on <em>CellType</em>, we simply call <code><a href = "https://rdrr.io/bioc/monocle/man/differentialGeneTest.html">differentialGeneTest</a></code> with a string specifying <em>fullModelFormulaStr</em>.  We don't have to specify the reduced model in this case, because the default of <em>~1</em> is what we want here. </p>

{% highlight R %}
diff_test_res <- differentialGeneTest(cds_subset,
          fullModelFormulaStr = "~CellType")
diff_test_res[,c("gene_short_name", "pval", "qval")]
{% endhighlight %}

<p> Note that all the genes are significantly differentially expressed as a
function of <em>CellType</em> except the housekeeping gene TBP, which we're
using a negative control. However, we don't know which genes correspond to
myoblast-specific genes (those more highly expressed in myoblasts versus
fibroblast specific genes.  We can again plot them with a jitter plot to see:
</p>

{%highlight R%}
plot_genes_jitter(cds_subset,
        grouping = "CellType",
        color_by = "CellType",
        nrow= 1,
        ncol = NULL,
        plot_trend = TRUE)
{%endhighlight%} -->

<!--
<h3>Comparing selected subsets of cells</h3>
<p>Often, you'll see one or more clusters and wonder what makes them different from other cells. Monocle provides several functions you can use to select cells of interest for downstream analysis </p>

{% highlight R %}
cds_subset = choose_cells()
{% endhighlight %}

<strong>XXX animated GIF of choosing cells</strong>

<p>Now that we have selected several specific clusters of cells, we can find genes that distinguish them:</p>
{% highlight R %}
cluster_models = fit_models(cds_subset,
                            model_formula_str = "~cluster")
fit_coefs = coefficient_table(cluster_models)
fit_coefs %>% filter(grepl("cluster", term) %>%
  select(gene_short_name, term, q_value, estimate)
{% endhighlight %}

XXX TODO SHOW OUTPUT XXX -->

<h3>Graph-autocorrelation analysis for comparing clusters</h3>

<p>In the L2 worm data, we identified a number of clusters that were very distinct as neurons: </p>
{% highlight R %}
neurons_cds = cds[,colData(cds)$assigned_cell_type == "Neurons"]
plot_cells(neurons_cds, color_cells_by="partition")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_neurons.png" width= 760>
</div>

<p>There are many subtypes of neurons, so perhaps the different neuron clusters correspond to different subtypes. To investigate which genes are expressed differentially across the clusters, we could use the regression analysis tools discussed above. However, Monocle provides an alternative way of finding genes that vary between groups of cells in UMAP or t-SNE space. The function <code>graph_test()</code> uses a statistic from spatial autocorrelation analysis called <a href="https://en.wikipedia.org/wiki/Moran%27s_I">Moran's I</a>, which Cao & Spielmann <emph>et al</emph> showed to be effective in finding genes that vary in single-cell RNA-seq datasets.</p>

<p>You can run <code>graph_test()</code> like this:</p>

{% highlight R %}
pr_graph_test_res = graph_test(neurons_cds, neighbor_graph="knn", cores=8)
pr_deg_ids = row.names(subset(pr_graph_test_res, q_value < 0.05))
{% endhighlight %}

<p>The data frame <code>pr_graph_test_res</code> has the Moran's I test results for each gene in the <code>cell_data_set</code>. If you'd like to rank the genes by effect size, sort this table by the <code>morans_I</code>column, which ranges from -1 to +1. A value of 0 indicates no effect, while +1 indicates perfect positive autocorrelation and suggests that a nearby cells have very similar values of a gene's expression. Significant values much less than zero are generally rare.</p>

<p>Positive values indicate a gene is expressed in a focal region of the UMAP space (e.g. specific to one or more clusters). But how do we associate genes with clusters? The next section explains how to collect genes into modules that have similar patterns of expression and associate them with clusters.</p>

<h3>Finding modules of co-regulated genes</h3>

<p>Once you have a set of genes that vary in some interesting way across the clusters, Monocle provides a means of grouping them into modules. You can call <code>find_gene_modules()</code>, which essentially runs UMAP on the genes (as opposed to the cells) and then groups them into modules using Louvain community analysis:</p>

{% highlight R %}
gene_module_df = find_gene_modules(neurons_cds[pr_deg_ids,], resolution=1e-2)
{% endhighlight %}

The data frame <code>gene_module_df</code> contains a row for each gene and identifies the module it belongs to. To see which modules are expressed in which clusters or partitions you can use two different approaches for visualization. The first is just to make a simple table that shows the aggregate expression of all genes in each module across all the clusters. Monocle provides a simple utility function called <code>aggregate_gene_expression</code> for this purpose:

{% highlight R %}
cell_group_df = tibble::tibble(cell=row.names(colData(neurons_cds)), cell_group=partitions(cds)[colnames(neurons_cds)])
agg_mat = aggregate_gene_expression(neurons_cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) = stringr::str_c("Partition ", colnames(agg_mat))

pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
                   scale="column", clustering_method="ward.D2",
                   fontsize=6)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_neuron_module_heatmap.png" width= 760>
</div>

<p>Some modules are highly specific to certain paritions of cells, while others are shared across multiple partitions. Note that <code>aggregate_gene_expression</code> can work with arbitrary groupings of cells and genes. You're not limited to looking at modules from <code>find_gene_modules()</code>, <code>clusters()</code>, and <code>partitions()</code>.</p>

The second way of looking at modules and their expression is to pass <code>gene_module_df</code> directly to <code>plot_cells()</code>. If there are many modules, it can be hard to see where each one is expressed, so we'll just look at a subset of them:

{% highlight R %}
plot_cells(neurons_cds,
           genes=gene_module_df %>% filter(module %in% c(16,38,33,42)),
           group_cells_by="partition",
           color_cells_by="partition",
           show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_neurons_selected_modules.png" width= 760>
</div>

<h3>Finding genes that change as a function of pseudotime </h3>
Identifying the genes that change as cells progress along a trajectory is a core objective of this type of analysis. Knowing the order in which genes go on and off can inform new models of development. For example, <a href="http://dx.doi.org/10.1016/j.cell.2018.12.003">Sharon and Chawla et al</a> recently analyzed pseudotime-dependent genes to arrive a whole new model of how islets form in the pancreas.</p>

<p>Let's return to the embryo data:</p>

{% highlight R %}
plot_cells(cds,
           color_cells_by = "cell.type",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_packer_cell_type.png" width= 760>
</div>

<p>How do we find the genes that are differentially expressed on the different paths through the trajectory? How do we find the ones that are restricted to the beginning of the trajectory? Or excluded from it?</p>

<p>Once again, we turn to <code>graph_test()</code>, this time passing it <code>neighbor_graph="principal_graph"</code>, which tells it to test whether cells at similar positions on the trajectory have correlated expression:</p>

{% highlight R %}
ciliated_cds_pr_test_res = graph_test(cds, neighbor_graph="principal_graph", cores=4)
pr_deg_ids = row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))
{% endhighlight %}

<p>Here are a couple of interesting genes that score as highly significant according to <code>graph_test()</code>:</p>

{% highlight R %}
plot_cells(cds, genes=c("hlh-4", "gcy-8", "dac-1", "oig-8"),
           show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,
           label_leaves=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_selected_markers.png" width= 760>
</div>

<p>As before, we can collect the trajectory-variable genes into modules:</p>

{% highlight R %}
gene_module_df = monocle3:::find_gene_modules(cds[pr_deg_ids,], resolution=c(0,10^seq(-6,-1)))
{% endhighlight %}

<p>Here we plot the aggregate module scores within each group of cell types as annotated by Packer & Zhu <emph>et al</emph>:</p>

{% highlight R %}
cell_group_df = tibble::tibble(cell=row.names(colData(cds)), cell_group=colData(cds)$cell.type)
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
pheatmap::pheatmap(agg_mat,
                    scale="column", clustering_method="ward.D2")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/emb_pseudotime_module_heatmap.png" width= 760>
</div>

We can also pass <code>gene_module_df</code> to <code>plot_cells()</code> as we did when we compared clusters in the L2 data above.

{% highlight R %}
plot_cells(cds,
           genes=gene_module_df %>% filter(module %in% c(29,20, 11,22)),
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_selected_pseudotime_modules.png" width= 760>
</div>

<p>Monocle offers another plotting function that can sometimes give a clearer view of a gene's dynamics along a single path. Let's pick one such path, the AFD cells, which are found in clusters 22, 38, and 35:</p>
{% highlight R %}
plot_cells(cds, show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_cluster.png" width= 760>
</div>

<p>The function <code>plot_genes_in_pseudotime()</code> takes a small set of genes and shows you their dynamics as a function of pseudotime:</p>
{% highlight R %}
AFD_genes = c("gcy-8", "dac-1", "oig-8")
AFD_lineage_cds = cds[rowData(AFD_lineage_cds)$gene_short_name %in% AFD_genes,
                      clusters(cds) %in% c(22, 28, 35)]

plot_genes_in_pseudotime(AFD_lineage_cds,
                         color_cells_by="embryo.time.bin",
                         min_expr=0.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_AFD_dynamic_genes.png" width= 500>
</div>

<p>You can see that <emph>dac-1</emph> is activated before the other two genes.</p>

<h3>Analyzing branches in single-cell trajectories </h3>

Analyzing the genes that are regulated around trajectory branch points often provides insights into the genetic circuits that control cell fate decisions. Monocle can help you drill into a branch point that corresponds to a fate decision in your system. Doing so is as simple as selecting the cells (and branch point) of interest with <code>choose_cells()</code>:

{% highlight R %}
cds_subset = choose_cells(cds)
{% endhighlight %}


<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/choose_branch_recording.gif" width= 760>
</div>

<p> And then calling <code>graph_test()</code> on the subset. This will identify genes with interesting patterns of expression that fall only within the region of the trajectory you selected, giving you a more refined and relevant set of genes.</p>
{% highlight R %}
subset_pr_test_res = graph_test(cds_subset, cores=4)
pr_deg_ids = row.names(subset(subset_pr_test_res, q_value < 0.05))
{% endhighlight %}

<p>Grouping these genes into modules can reveal fate specific genes or those that are activate immediate prior to or following the branch point:</p>

{% highlight R %}
gene_module_df = monocle3:::find_gene_modules(cds_subset[pr_deg_ids,], resolution=1e-2)
{% endhighlight %}

<p>We will organize the modules by their similarity (using <code>hclust</code>) over the trajectory so it's a little easier to see which ones come on before others:</p>

{% highlight R %}
cell_group_df = tibble::tibble(cell=row.names(colData(cds_subset)), cell_group=clusters(cds_subset)[colnames(cds_subset)])
agg_mat = aggregate_gene_expression(cds_subset, gene_module_df, cell_group_df)
module_dendro = hclust(dist(agg_mat))
gene_module_df$module <- factor(gene_module_df$module, levels = row.names(agg_mat)[module_dendro$order])

plot_cells(cds_subset,
           genes=gene_module_df,
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
{% endhighlight %}

<p>
<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_AFD_modules.png" width= 760>
</div>

<h2>Major updates in Monocle 3</h2>

<p>Monocle 3 has been re-engineered to analyze large, complex single-cell datasets. The algorithms at the core of Monocle 3 are highly scalable and can handle millions of cells. Monocle 3 adds some powerful new features that enable the analysis of organism- or embryo-scale experiments:</p>

<ul>
    <li>A better structured workflow to learn developmental trajectories.
    <li>Support for the <a href="https://github.com/lmcinnes/umap">UMAP</a> algorithm to initialize trajectory inference.
    <li>Support for trajectories with multiple roots.
    <li>Ways to learn trajectories that have loops or points of convergence.
    <li>Algorithms that automatically partition cells to learn disjoint or parallel trajectories using ideas from <a href="https://www.biorxiv.org/content/early/2017/10/25/208819">"approximate graph abstraction"</a>.
    <li>A new statistical test for genes that have trajectory-dependent expression. This replaces both the old <code>differentialGeneTest()</code> function and <code>BEAM()</code>.
    <li>A 3D interface to visualize trajectories and gene expression.
</ul>

<p>Most of the algorithmic details in Monocle 3 are described in <a href="http://dx.doi.org/10.1038/s41586-019-0969-x">Cao & Spielmann <emph>et al</emph></a>. </p>

<!--
<h2>Appendices</h2>

<h2>Theory Behind Monocle </h2>

<h3>Reversed graph embedding </h3>

<p> Single-cell expression datasets are some of the largest and most complex encountered
in genomics. Even the smallest single-cell RNA-Seq experiments sample hundreds of cells, measuring the
expression level of the more than 20,000 genes in each cell. Visualizing these
datasets, identifying cells of different types, and comparing them to one another
all pose major bioinformatics challenges. </p>

<p> <em>Manifold learning</em> is a common strategy for dealing with complex, high-dimensional
data. The premise of this approach is simple: the data may reside in a very high-dimensional space,
but the intrinsic structure of the dataset is much simpler. Moreover, the data
are not random - they are generated by a process that can be understood by
inspecting the global structure of the dataset. For example, a single single-cell RNA-Seq
experiment may reside in 20,000 dimensions, but the cells might all lie on or "near"
a curve <em>embedded</em> within a much lower dimensional space. For example, we
might expect that cells in different phases of the cell cycle be distributed along
a closed loop. Indeed a recent large-scale single-cell RNA-Seq study found exactly
that <a href= "https://www.ncbi.nlm.nih.gov/pubmed/26000488">[11]</a>. </p>

<p>Manifold learning often involves <em>dimensionality reduction</em> techniques as a
first step. Conventional dimensionality reduction approaches (for
example, PCA, ICA, Isomap, LLE, etc.) are limited in their ability to explictly
recover the intrinisic structure from the data. </p>

<p>Monocle 2 uses a technique called <em>reversed graph embedding</em> <a href= "http://www.biorxiv.org/content/early/2017/02/21/110668">[10,</a> <a href= "http://ieeexplore.ieee.org/document/7769209/?reload=true">12]</a>  to learn the
structure of the manifold that describes a single-cell experiment. It simultaneously: </p>

<ol>
<li> Reduces high dimensional expression data into a lower dimension space.
<li> Learns an explicit, smooth manifold that generates the data.
<li> Assigns each cell to its position on that manifold
</ol>

<p>Together, these tasks allow Monocle 2 to order cells in pseudotime in an entirely
unsupervised, data-driven way. Importantly, Monocle 2 learns manifolds that are
trees without needing any <em>a priori</em> information about the structure of the
tree. Users do not need to provide Monocle 2 with constraints on the number of branches, etc.
These are learned from the data. This allows Monocle 2 to to discriminate between
linear and branched trajectories automatically. To our knowledge, Monocle 2 is the first
trajectory reconstruction algorithm to learn smooth tree-like manifolds without
needing to know its high-level structure ahead of time.

<p>Reversed graph embedding simultaneously learns a <em>principal graph</em> that
approximates the manifold, as well as a function that maps points on the graph
(which is embedded in low dimensions) back to the original high dimensional space.
Reversed graph embedding aims to learn both a set of <em>latent points</em>
$$ \mathcal{Z} = \{\mathbf{z}_1, ..., \mathbf{z}_M\}$$corresponding to the input data
that reside in the low-dimensional space along with a graph $\mathcal{G}$ that
connects them. This graph approximates the manifold. In order to map points on
the manifold back to the original high-dimensional input space, we also need to
learn a function $f_{\mathcal{G}}$.

<p>Learning a good reversed graph embedding can be described as an optimization problem that
joint captures the positions of the latent points $\mathbf{z}$, the graph $\mathcal{G}$, and the function
$f_\mathcal{G}$.

<p>To learn the positions of the latent points $\mathbf{z}$, we must optimize:

\begin{equation}
\mathop{min}_{f_g \in \mathcal{F}} \mathop{min}_{\{\mathbf{z}_1, ...,
\mathbf{z}_M\}} \sum_{i = 1}^N ||\mathbf{x}_i - f_g (\mathbf{z}_i)||^2
\end{equation}

<p>Given a set of latent point coordinates, the optimization of graph inference can
be represented as:

\begin{equation} \label{eq:mintree}
\mathop{min}_{f_\mathcal{G} \in \mathcal{F}} \mathop{min}_{\{\mathbf{z}_1, ..., \mathbf{z}_M\}} \sum_{(V_i, V_j) \in
\mathcal{E}} b_{i,j}||f_g(\mathbf{z}_i) - f_g(\mathbf{z}_j)||^2
\end{equation}

<p>where
$\mathcal{X} = \{ \mathbf{x}_1, ..., \mathbf{x}_N\}$ are the original
single-cell expression profiles. The $V_i$ are the the vertices of the
undirected graph $\mathcal{G} = (\mathcal{V}, \mathcal{E})$. The weights for the
edge in $\mathcal{E}$ are encoded as $b_{ij}$.

<p>The first optimization problem aims to position the latent points such that their
image under $f_\mathcal{G}$ (that is, their corresponding positions in the high-dimensional space)
will be "close" to the input data. The second optimization aims to keep latent
points that are close to one another in the low dimensional space close to one
another in the high dimensional space as well. These two goals must be balanced
against one another. Reversed graph embedding achieves this through the parameter
$\lambda$

\begin{equation}
\mathop{min}_{\mathcal{G} \in \hat{\mathcal{G}}_b}\mathop{min}_{f_g \in \mathcal{F}} \mathop{min}_{\{\mathbf{z}_1, ...,
\mathbf{z}_M\}} \sum_{i = 1}^N ||\mathbf{x}_i - f_g (\mathbf{z}_i)||^2 + \frac{\lambda}{2} \sum_{(V_i, V_j) \in \mathcal{E}}
b_{i,j}||f_g(\mathbf{z}_i) - f_g(\mathbf{z}_j)||^2
\end{equation}

<p>Reversed graph embedding requires a feasible set $\hat{\mathcal{G}}_b$ of graphs and a
mapping function $f_\mathcal{G}$. In practice, implementing reversed graph embedding
requires that we place some constraints on $\hat{\mathcal{G}}_b$ and $f_\mathcal{G}$.
As work on reversed graph embedding continues, we anticipate that more general
schemes that consider a wider range of feasible graphs and mapping functions will
become available. Monocle users should expect more general reversed graph embedding
schemes in future versions.

<p>Mao <em>et al</em> initially described two specific ways to implement the general framework
of reversed graph embedding. Both are briefly summarized below. See the original
paper on DDRTree for more details. Monocle 2 uses the second scheme, but can easily be
run in a mode that corresponds to the first.
 -->


<h2>Citation </h2>


If you use Monocle to analyze your experiments, please cite:

{% highlight R %}

citation("monocle3")

## Cole Trapnell and Davide Cacchiarelli et al (2014): The dynamics and regulators of cell fate decisions are
## revealed by pseudo-temporal ordering of single cells. Nature Biotechnology
##
## Xiaojie Qiu et al (2017): Single-cell mRNA quantification and differential analysis with Census. Nature Methods
##
## Xiaojie Qiu et al (2017): Reverse graph embedding resolves complex single-cell developmental trajectories.
## Nature Methods
##
## Junyue Cao, Malte Spielmann et al (2019): The single-cell transcriptional landscape of mammalian organogenesis.
## Nature

{% endhighlight %}


<h2>Acknowledgements </h2>

<p>Monocle was originally built by Cole Trapnell and Davide Cacchiarelli, with substantial design input from John Rinn and Tarjei Mikkelsen. We are grateful to Sharif Bordbar, Chris Zhu, Amy Wagers and the Broad RNAi platform for technical assistance, and Magali Soumillon for helpful discussions. Cole Trapnell was supported by a Damon Runyon Postdoctoral Fellowship. Davide Cacchiarelli was supported by a Human Frontier Science Program Fellowship. Cacchiarelli and Mikkelsen were also supported by the Harvard Stem Cell Institute. John Rinn was the Alvin and Esta Star Associate Professor. This work was supported by NIH grants 1DP2OD00667, P01GM099117, and P50HG006193-01. This work was also supported in part by the Single Cell Genomics initiative, a collaboration between the Broad Institute and Fluidigm Inc.</p>

<p>Monocle versions 2 and 3 were developed by Cole Trapnell's lab. Significant portions were written by Xiaojie Qiu and Hannah Pliner. The work was supported by NIH grant 1DP2HD088158, the W. M. Keck Foundation, as well as an Alfred P. Sloan Foundation Research Fellowship. Hannah Pliner is supported by the <a href="https://brotmanbaty.org/">Brotman Baty Institute</a>.</p>

<h2>References </h2>

<ol>
  <li>Cole Trapnell*, Davide Cacchiarelli*, Jonna Grimsby, Prapti Pokharel, Shuqiang Li, Michael Morse, Niall J. Lennon, Kenneth J. Livak, Tarjei S. Mikkelsen, and John L. Rinn.<br/>
  <a href = "http://www.nature.com/nbt/journal/v32/n4/abs/nbt.2859.html">
  The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</a>.<br/> Nature Biotechnology, 2014.<br/><br/> </li>

  <li>Junyue Cao*, Jonathan S. Packer*, Vijay Ramani, Darren A. Cusanovich, Chau Huynh, Riza Daza, Xiaojie Qiu, Choli Lee, Scott N. Furlan, Frank J. Steemers, Andrew Adey, Robert H. Waterston, Cole Trapnell**, Jay Shendure** .<br/>
  <a href = "http://http//science.sciencemag.org/content/357/6352/661">
  Comprehensive single-cell transcriptional profiling of a multicellular organism</a>.<br/>Science, 2017.<br/><br/>  </li>

  <li>Jacob H. Levine, Erin F. Simonds, Sean C. Bendall, Kara L. Davis, El-ad D. Amir, Michelle Tadmor, Oren Litvin, Harris Fienberg, Astraea Jager, Eli Zunder, Rachel Finck, Amanda L. Gedman, Ina Radtke, James R. Downing, Dana Peer** and Garry P. Nolan**.<br/>
    <a href = "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4508757/">
      Data-driven phenotypic dissection of AML reveals progenitor-like cells that correlate with prognosis</a>.<br/>Cell, 2015.<br/><br/>  </li>

  <li>F. Alexander Wolf,, Fiona K. Hamey, Mireya Plass, Jordi Solana, Joakim S. Dahlin, Berthold Gttgens, Nikolaus Rajewsky, Lukas Simon and Fabian J. Theis<br/>
    <a href = "https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x">
      PAGA: graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells</a>.<br/>Genome biology, 2018.<br/><br/>  </li>

  <li>Junyue Cao*, Malte Spielmann*, Xiaojie Qiu, Xingfan Huang, Daniel M. Ibrahim, Andrew J. Hill, Fan Zhang, Stefan Mundlos, Lena Christiansen, Frank J. Steemers, Cole Trapnell**, and Jay Shendure** <br/>
    <a href = "http://dx.doi.org/10.1038/s41586-019-0969-x">
          The single-cell transcriptional landscape of mammalian organogenesis</a>.<br/>Nature, 2019.<br/><br/>  </li>

  <li>Jonathan S. Packer*, Qin Zhu*, Chau Huynh, Priya Sivaramakrishnan, Elicia Preston, Hannah Dueck, Derek Stefanik, Kai Tan, Cole Trapnell, Junhyong Kim**, Robert H. Waterston**, John I. Murray** <br/>
    <a href = "http://dx.doi.org/10.1101/565549">
      A lineage-resolved molecular atlas of C. elegans embryogenesis at single cell resolution</a>.<br/>bioRxiv, 2019.<br/><br/>  </li>

  <li>Nadav Sharon*, Raghav Chawla*, Jonas Mueller, Jordan Vanderhooft, Luke James Whitehorn, Benjamin Rosenthal, Mads Gurtler, Ralph R. Estanboulieh, Dmitry Shvartsman, David K. Gifford, Cole Trapnell** and Doug Melton**<br/>
        <a href = "http://dx.doi.org/10.1016/j.cell.2018.12.003">
          A peninsular structure coordinates asynchronous differentiation with morphogenesis to generate pancreatic islets</a>.<br/>Cell, 2019.<br/><br/>  </li>

  <li>Xiaojie Qiu, Qi Mao, Ying Tang, Li Wang, Raghav Chawla, Hannah Pliner, and Cole Trapnell<br/>
    <a href = "http://dx.doi.org/doi:10.1038/nmeth.4402">
      Reversed graph embedding resolves complex single-cell developmental trajectories</a>.<br/>Nature methods, 2017<br/><br/>  </li>

   <li>X Qiu, A Hill, J Packer, D Lin, YA Ma, and C Trapnell.<br/>
        <a href = "http://dx.doi.org/10.1038/nmeth.4150">
          Single-cell mrna quantification and differential analysis with census</a>.<br/>Nature methods, 2017<br/><br/>  </li>

</ol>
<!--
<p> [1] Cole Trapnell, Davide Cacchiarelli, Jonna Grimsby, Prapti Pokharel, Shuqiang Li, Michael Morse, Niall J. Lennon, Kenneth J. Livak, Tarjei S. Mikkelsen, and John L. Rinn. <a href = "http://www.nature.com/nbt/journal/v32/n4/abs/nbt.2859.html"> The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</a>. Nature Biotechnology, 2014. </p>

<p> [2] Cole Trapnell, Adam Roberts, Loyal Goff, Geo Pertea, Daehwan Kim, David R Kelley, Harold Pimentel, Steven L Salzberg, John L Rinn, and Lior Pachter. <a href = "https://www.ncbi.nlm.nih.gov/pubmed/22383036"> Differential gene and transcript expression analysis of RNA-seq experiments with TopHat and Cufflinks</a>. Nature Protocols, 7(3):562578, March 2012. </p>

<p> [3] Laurens van der Maaten and Geoffrey Hinton. <a href = "http://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf"> Visualizing data using t-SNE</a>. J. Mach. Learn. Res., 9(Nov):2579 2605, 2008. </p>

<p> [4] Alex Rodriguez. Alessandro Laio. <a href = "http://science.sciencemag.org/content/344/6191/1492"> Clustering by fast search and find of density peaks</a>. Science, 344:14921496, 2014. </p>

<p> [5] Hadley Wickham. <a href = "http://www.springer.com/us/book/9780387981413"> ggplot2: Elegant Graphics for Data Analysis</a>. Springer-Verlag New York, 2009. </p>

<p> [6] Simon Anders and Wolfgang Huber. <a href = "https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106"> Differential expression analysis for sequence count data</a>. Genome Biol., 11(10):R106, 2010. </p>

<p> [7] Qi Mao, Li Wang, Steve Goodison, and Yijun Sun. <a href= "http://dl.acm.org/citation.cfm?id= 2783309"> Dimensionality reduction via graph structure learning</a>. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 765774. ACM, 2015. </p>

<p> [8] X Qiu, A Hill, J Packer, D Lin, YA Ma, and C Trapnell. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/28114287"> Single-cell mrna quantification and differential analysis with census</a>. Nature methods, 2017. </p>

<p> [9] Rahul Satija, Jeffrey A Farrell, David Gennert, Alexander F Schier, and Aviv Regev. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/25867923"> Spatial reconstruction of single-cell gene expression data</a>. Nat. Biotechnol., 33(5):495502, May 2015. </p>

<p> [10] Xiaojie Qiu, Qi Mao, Ying Tang, Li Wang, Raghav Chawla, Hannah Pliner, and Cole Trapnell. <a href= "http://www.biorxiv.org/content/early/2017/02/21/110668"> Reversed graph embedding resolves complex single-cell developmental trajectories</a>. 21 February 2017. </p>

<p> [11] Evan Z Macosko, Anindita Basu, Rahul Satija, James Nemesh, Karthik Shekhar, Melissa Goldman, Itay Tirosh, Allison R Bialas, Nolan Kamitaki, Emily M Martersteck, John J Trombetta, David A Weitz, Joshua R Sanes, Alex K Shalek, Aviv Regev, and Steven A McCarroll. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/26000488">Highly parallel genome-wide expression profiling of individual cells using nanoliter droplets</a>. Cell, 161(5):12021214, 2015. </p>

<p> [12] Qi Mao, Li Wang, Ivor Tsang, and Yijun Sun. <a href= "http://ieeexplore.ieee.org/document/7769209/?reload=true">Principal graph and structure learning based on reversed graph embedding </a>. IEEE Trans. Pattern Anal. Mach. Intell., 5 December 2016. </p>

<p> [13] Cabili, Moran N. et al. <a href = "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3185964/">Integrative Annotation of Human Large Intergenic Noncoding RNAs Reveals Global Properties and Specific Subclasses</a>. Genes & Development 25.18 (2011): 19151927. PMC. Web. 21 June 2017. </p>
 -->

</div>
</div>
</div>
