---
permalink: /docs/starting/
sidemenu: true
description: "Getting started with Monocle 3."
modified: 2019-09-13
tags: [monocle, manual, vignette]
---

<div class= "container">
  <div class= "row">
    <div class= "col-sm-4">
      <ul class="section-nav" id= "toc" data-spy= "affix" data-toggle= "toc">
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/introduction">Introduction</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/updates">Major updates in Monocle 3</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/installation">Installing Monocle 3</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/help">Getting help</a></li>
        <li class="toc-entry toc-h2"><a class="active" href="{{ site.baseurl }}/docs/starting">Getting started with Monocle 3</a>
          <ul>
            <li class="toc-entry toc-h3"><a href="#at-a-glance">Workflow steps at a glance</a></li>
            <li class="toc-entry toc-h3"><a href="#loading-data">Loading your data</a></li>
            <li class="toc-entry toc-h3"><a href="#cell_data_set">The cell_data_set class</a></li>
            <li class="toc-entry toc-h3"><a href="#10x-output">Generate a cell_data_set from 10X output</a></li>
            <li class="toc-entry toc-h3"><a href="#large-datasets">Working with large data sets</a></li>
            <li class="toc-entry toc-h3"><a href="#combine_cds">Combining CDS objects</a></li>
          </ul>
        </li>
<!--        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/alignment">Pre-process your data</a></li>  -->
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/clustering">Clustering and classifying your cells</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/trajectories">Constructing single-cell trajectories</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/differential">Differential expression analysis</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/projection">Projecting query data onto a reference</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/store_monocle_objects">Storing monocle objects</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/cicero">Single-cell ATAC-seq data</a></li>
        <li class="toc-entry toc-h2"><a href="{{ site.baseurl }}/docs/citations">Citations and acknowledgments</a></li>
      </ul>
    </div>
    <!-- main content area -->
    <div class= "col-sm-8">
      <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="{{ site.baseurl }}/">Home</a></li>
          <li class="breadcrumb-item"><a href="{{ site.baseurl }}/docs/introduction">Docs</a></li>
          <li class="breadcrumb-item active" aria-current="page">Getting started</li>
        </ol>
      </nav>
      
      
      <h2>Getting started with Monocle 3</h2>
      <h3 id="at-a-glance">Workflow steps at a glance</h3>
      
      <div class= "text-center">
        <img src= "{{site.baseurl}}/images/monocle3_new_workflow.png" width= 760>
      </div>
      
      <p>Below, you can see snippets of code that highlight the main steps of
        Monocle 3. Click on the section headers to jump to the detailed sections
        describing each one and allowing you to try the steps on example data. 
      </p>
      
      <h4><a href="{{ site.baseurl }}/docs/starting/#cell_data_set">Store data in a cell_data_set object</a></h4>
      The first step in working with Monocle 3 is to load up your data into
      Monocle 3's main class, <code><a href = "{{ site.baseurl }}/docs/starting/#cell_data_set">cell_data_set</a></code>:
 
{% highlight R %}
cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)

## Step 1: Normalize and pre-process the data
cds <- preprocess_cds(cds, num_dim = 100)
{% endhighlight %}

<h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/docs/clustering/#batch-effects">Remove batch effects</a> </h4>
You can subtracted unwatched batch effects or align cells from similar (but not exactly) the same conditions using several different methods in Monocle 3.

{% highlight R %}
## Step 2: Remove batch effects with cell alignment
cds <- align_cds(cds, alignment_group = "batch")
{% endhighlight %}

<h4><a href= "{{ site.baseurl }}/docs/clustering/">Cluster your cells</a></h4>

You can easily cluster your cells to find new types:
{% highlight R %}
## Step 3: Reduce the dimensions using UMAP
cds <- reduce_dimension(cds)

## Step 4: Cluster the cells
cds <- cluster_cells(cds)
{% endhighlight %}

<h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/docs/trajectories/">Order cells in pseudotime along a trajectory</a> </h4>
Now, put your cells in order by how much progress they've made through whatever
process you're studying, such as differentiation, reprogramming, or an immune
response.

{% highlight R %}
## Step 5: Learn a graph
cds <- learn_graph(cds)

## Step 6: Order cells
cds <- order_cells(cds)

plot_cells(cds)
{% endhighlight %}
      
      <h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/docs/differential">Perform differential expression analysis</a> </h4>
      Compare groups of cells in myriad ways to find differentially expressed genes,
      controlling for batch effects and treatments as you like:
      
{% highlight R %}
# With regression:
gene_fits <- fit_models(cds, model_formula_str = "~embryo.time")
fit_coefs <- coefficient_table(gene_fits)
emb_time_terms <- fit_coefs %>% filter(term == "embryo.time")
emb_time_terms <- emb_time_terms %>% mutate(q_value = p.adjust(p_value))
sig_genes <- emb_time_terms %>% filter (q_value < 0.05) %>% pull(gene_short_name)

# With graph autocorrelation:
pr_test_res <- graph_test(cds,  neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(pr_test_res, q_value < 0.05))
{% endhighlight %}

<hr style="border: 1px solid gray;">
      <h2>Get started</h2>
      <h3>Load Monocle 3</h3>
{% highlight R %}
library(monocle3)

# The tutorial shown below and on subsequent pages uses two additional packages:
library(ggplot2)
library(dplyr)
{% endhighlight %}   

      <h3 id="loading-data">Loading your data</h3>

      Monocle 3 takes as input cell by gene expression matrix. Monocle 3 is designed
      for use with absolute transcript counts (e.g. from UMI experiments). Monocle 3
      works "out-of-the-box" with the transcript count matrices produced by
      <a href= "https://support.10xgenomics.com/single-cell/software/overview/welcome">Cell Ranger</a>,
      the software pipeline for analyzing experiments from the 10X Genomics Chromium
      instrument. Monocle 3 also works well with data from other RNA-Seq workflows
      such as <a href= "https://science.sciencemag.org/content/357/6352/661">sci-RNA-Seq</a>
      and instruments like the Biorad ddSEQ.

      <h3 id="cell_data_set">The cell_data_set class</h3>

      Monocle holds single-cell expression data in objects of the
      <code>cell_data_set</code> class. The class is derived from the Bioconductor
      <code><a href="http://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html">SingleCellExperiment</a></code> class,
      which provides a common interface familiar to those who have analyzed other
      single-cell experiments with Bioconductor. The class requires three input files:
      <p>
        <ul>
          <li> <code>expression_matrix</code>, a numeric matrix of expression values,
            where rows are genes, and columns are cells 
          </li>
          <li> <code>cell_metadata</code>, a data frame, where rows are cells, and
            columns are cell attributes (such as cell type, culture condition, day
            captured, etc.)
          </li>
          <li> <code>gene_metadata</code>, an data frame, where rows are features (e.g.
            genes), and columns are gene attributes, such as biotype, gc content,
            etc.
          </li>
        </ul>
      </p>
      
      <div class= "panel panel-warning">
        <div class= "panel-heading">
          <h3 class= "panel-title" data-toc-skip>Required dimensions for input files</h3>
        </div>
        <div class= "panel-body">
          The expression value matrix <strong>must</strong>:
          <ul>
            <li>have the same number of columns as the <code>cell_metadata</code> has
              rows.
            </li>
            <li>have the same number of rows as the <code>gene_metadata</code> has
              rows.
            </li>
          </ul>
          Additionally:
          <ul>
            <li>row names of the <code>cell_metadata</code> object should match the column
              names of the expression matrix. 
            </li>
            <li>row names of the <code>gene_metadata</code> object should match row names
              of the expression matrix.
            </li>
            <li> one of the columns of the <code>gene_metadata</code> should be named
              "gene_short_name", which represents the gene symbol or simple name (generally
              used for plotting) for each gene.
            </li>
          </ul>
        </div>
      </div>
      <h4>Generate a cell_data_set</h4>
      
      <p>You can create a new <code>cell_data_set</code> (CDS) object as follows:</p>
      
      <p>
{% highlight R %}
# Load the data
expression_matrix <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_expression.rds"))
cell_metadata <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_colData.rds"))
gene_annotation <- readRDS(url("http://staff.washington.edu/hpliner/data/cao_l2_rowData.rds"))

# Make the CDS object
cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
{% endhighlight %}
      </p>
      
      <h3 id="10x-output">Generate a cell_data_set from 10X output</h3>
      <p>To input data from 10X Genomics Cell Ranger, you can use the
        <code>load_cellranger_data</code> function:
      </p>
      
      <p><strong>Note:</strong> <code>load_cellranger_data</code> takes an argument <code>umi_cutoff</code>
        that determines how many reads a cell must have to be included. <strong>By default, this is set to 100</strong>.
        If you would like to include all cells, set <code>umi_cutoff</code> to 0.
      </p>
      <p>
        For <code>load_cellranger_data</code> to find the correct files, you must provide a path to the folder containing the
        un-modified Cell Ranger 'outs' folder. Your file structure should look like: 10x_data/outs/filtered_feature_bc_matrix/
        where filtered_feature_bc_matrix contains files features.tsv.gz, barcodes.tsv.gz and matrix.mtx.gz. 
        (<code>load_cellranger_data</code> can also handle Cell Ranger V2 data where "features" is substituted for "gene" and 
        the files are not gzipped.)
      </p>
{% highlight R %}
# Provide the path to the Cell Ranger output.
cds <- load_cellranger_data("~/Downloads/10x_data")
{% endhighlight %}

      <p>
        Alternatively, you can use <code>load_mm_data</code> to load any data in MatrixMarket format by providing the matrix files
        and two metadata files (features information and cell information). For more details, run <code>?load_mm_data</code>
      </p>
{% highlight R %}
cds <- load_mm_data(mat_path = "~/Downloads/matrix.mtx", 
                    feature_anno_path = "~/Downloads/features.tsv", 
                    cell_anno_path = "~/Downloads/barcodes.tsv")
{% endhighlight %}

      <h3 id="large-datasets">Working with large data sets</h3>
          
      <p> Some single-cell RNA-Seq experiments report measurements from tens of
        thousands of cells or more. As instrumentation improves and costs drop,
        experiments will become ever larger and more complex, with many conditions,
        controls, and replicates. A matrix of expression data with 50,000 cells and a
        measurement for each of the 25,000+ genes in the human genome can take up a
        lot of memory. However, because current protocols typically don't capture all
        or even most of the mRNA molecules in each cell, many of the entries of
        expression matrices are zero. Using <i>sparse matrices</i> can help you work
        with huge datasets on a typical computer. We generally recommend the use of
        sparse matrices for most users, as it speeds up many computations even for
        more modestly sized datasets. 
      </p>
          
      <p> To work with your data in a sparse format, simply provide it to Monocle 3
        as a sparse matrix from the <code>Matrix</code> package: 
      </p>
      
      <p>
{% highlight R %}
cds <- new_cell_data_set(as(umi_matrix, "sparseMatrix"),
cell_metadata = cell_metadata,
gene_metadata = gene_metadata)
{% endhighlight %}
      </p>
      
      <p>
        <div class= "panel panel-warning">
          <div class= "panel-heading">
            <h3 class= "panel-title" data-toc-skip>Don't accidentally convert to a dense expression matrix</h3>
          </div>
          <div class= "panel-body">
            The output from a number of RNA-Seq pipelines, including Cell Ranger, is
            already in a sparseMatrix format (e.g. MTX). If so, you should just pass it
            directly to <code>new_cell_data_set</code> without first converting it to a
            dense matrix (via <code>as.matrix()</code>, because that may exceed your
            available memeory.
          </div>
        </div>
      </p>
      
      Monocle's sparse matrix support is provided by the <code>Matrix</code> package.
      Other sparse matrix packages, such as <code>slam</code> or
      <code>SparseM</code> are not supported.
      
      <h3 id="combine_cds">Combining CDS objects</h3>
      <p>
        If you have multiple CDS objects that you would like to analyze together, use our 
        <code>combine_cds</code>. <code>combine_cds</code> takes a list of CDS objects and
        combines them into a single CDS object.
      </p>
      
{% highlight R %}
# make a fake second cds object for demonstration
cds2 <- cds[1:100,]

big_cds <- combine_cds(list(cds, cds2))
{% endhighlight %}
      
      <h4>Options</h4>
      <p>
        <code>keep_all_genes</code>: When TRUE (default), all genes are kept even if they don't match 
        between the different CDSs. Cells that do not have a given gene in their CDS will 
        be marked as having zero expression. When FALSE, only the genes in common among all
        CDSs will be kept. 
      </p>
      <p>
        <code>cell_names_unique</code>: When FALSE (default), the cell names in the CDSs are not
        assumed to be unique, and so a CDS specifier is appended to each cell name. When TRUE, 
        no specifier is added.
      </p>
      <a href="{{ site.baseurl }}/docs/help" class="btn btn-info btn-sm btn-prev" role="button">Previous</a>
      <a href="{{ site.baseurl }}/docs/clustering" class="btn btn-success btn-sm btn-next" role="button">Next</a>
    </div>
  </div>
</div>
